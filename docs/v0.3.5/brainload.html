

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Brainload :: Documentation &mdash; brainload v0.3.5 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Brainload Example Workflows" href="workflows.html" />
    <link rel="prev" title="Welcome to brainload’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> brainload
          

          
          </a>

          
            
            
              <div class="version">
                0.3.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Brainload API Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.freesurferdata">brainload.freesurferdata module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.annotations">brainload.annotations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.nitools">brainload.nitools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.brainlocate">brainload.brainlocate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.brainvoxlocate">brainload.brainvoxlocate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.brainwrite">brainload.brainwrite module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.stats">brainload.stats module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.surfacegraph">brainload.surfacegraph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.braindescriptors">brainload.braindescriptors module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.spatial">brainload.spatial module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-brainload.meshexport">brainload.meshexport module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="workflows.html">Brainload Example Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="braintools.html">Brainload Command Line Tools</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">brainload</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Brainload :: Documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-brainload">
<span id="brainload-api-documentation"></span><h1>Brainload API Documentation<a class="headerlink" href="#module-brainload" title="Permalink to this headline">¶</a></h1>
<p>Brainload high-level API functions.</p>
<dl class="function">
<dt id="brainload.subject">
<code class="descclassname">brainload.</code><code class="descname">subject</code><span class="sig-paren">(</span><em>subject_id</em>, <em>surf='white'</em>, <em>measure='area'</em>, <em>hemi='both'</em>, <em>subjects_dir=None</em>, <em>meta_data=None</em>, <em>load_surface_files=True</em>, <em>load_morphometry_data=True</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.subject" title="Permalink to this definition">¶</a></dt>
<dd><p>Load FreeSurfer brain morphometry and/or mesh data for a single subject.</p>
<p>High-level interface to load FreeSurfer brain data for a single space. This parses the data for the surfaces of this subject. If you want to load data that has been mapped to an average subject like ‘fsaverage’, use <cite>subject_avg</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em><em>, </em><em>optional</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Defaults to ‘area’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>meta_data</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – A dictionary that should be merged into the return value <cite>meta_data</cite>. Defaults to the empty dictionary if omitted.</li>
<li><strong>load_surface_files</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load mesh data. If set to <cite>False</cite>, the first return values <cite>vert_coords</cite> and <cite>faces</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
<li><strong>load_morphometry_data</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load morphometry data. If set to <cite>False</cite>, the first return value <cite>morphometry_data</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. Note that the two hemispheres do in general NOT have the same number of vertices.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘subject’. This means that the data loaded represent morphometry data taken from the subject’s surface (as opposed to data mapped to a common or average subject).</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for both hemispheres and white surface of subject1 in the directory defined by the environment variable SUBJECTS_DIR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we are a bit more explicit about what we want to load:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_home</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">user_home</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometimes we do not care for the mesh, e.g., we only want the morphometry data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">load_surface_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>…or the other way around (mesh only, no morphometry data):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">load_morphometry_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.subject_avg">
<code class="descclassname">brainload.</code><code class="descname">subject_avg</code><span class="sig-paren">(</span><em>subject_id</em>, <em>measure='area'</em>, <em>surf='white'</em>, <em>display_surf='white'</em>, <em>hemi='both'</em>, <em>fwhm='10'</em>, <em>subjects_dir=None</em>, <em>average_subject='fsaverage'</em>, <em>subjects_dir_for_average_subject=None</em>, <em>meta_data=None</em>, <em>load_surface_files=True</em>, <em>load_morphometry_data=True</em>, <em>custom_morphometry_files=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.subject_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Load morphometry data that has been mapped to an average subject for a subject, i.e., standard space data.</p>
<p>Load data for a single subject that has been mapped to an average subject like the <cite>fsaverage</cite> subject from FreeSurfer. Can also load the mesh of an arbitrary surface for the average subject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em><em>, </em><em>optional</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Defaults to ‘area’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>fwhm</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Which averaging version of the data should be loaded. FreeSurfer usually generates different standard space files with a number of smoothing settings. Defaults to ‘10’. If None is passed, the <cite>.fwhmX</cite> part is omitted from the file name completely. Set this to ‘0’ to get the unsmoothed version.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the average subject to which the data was mapped. Defaults to ‘fsaverage’.</li>
<li><strong>display_surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The surface of the average subject for which the mesh should be loaded, e.g., ‘white’, ‘pial’, ‘inflated’, or ‘sphere’. Defaults to ‘white’. Ignored if <cite>load_surface_files</cite> is <cite>False</cite>.</li>
<li><strong>subjects_dir_for_average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This can be used if the average subject is not in the same directory as all your study subjects. Defaults to the setting of <cite>subjects_dir</cite>.</li>
<li><strong>meta_data</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – A dictionary that should be merged into the return value <cite>meta_data</cite>. Defaults to the empty dictionary if omitted.</li>
<li><strong>load_surface_files</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load mesh data. If set to <cite>False</cite>, the first return values <cite>vert_coords</cite> and <cite>faces</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
<li><strong>load_morphometry_data</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load morphometry data. If set to <cite>False</cite>, the first return value <cite>morphometry_data</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
<li><strong>custom_morphometry_files</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Cutom filenames for the left and right hemispjere data files that should be loaded. A dictionary of strings with exactly the following two keys: <cite>lh</cite> and <cite>rh</cite>. The value strings must contain hardcoded file names or template strings for them. As always, the files will be loaded relative to the <cite>surf/</cite> directory of the respective subject. Example: <cite>{‘lh’: ‘lefthemi.nonstandard.mymeasure44.mgh’, ‘rh’: ‘righthemi.nonstandard.mymeasure44.mgh’}</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the average subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the average subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the average subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. In many cases, your average subject will have the same number of vertices for both hemispheres and you will know this number beforehand, so you may not have to worry about this at all.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘common’. This means that the data loaded represent morphometry data that has been mapped to a common or average subject.</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
<li><cite>display_subject</cite> : the name of the common or average subject. This is the subject the surface meshes originate from. Ususally ‘fsaverage’.</li>
<li><cite>display_surf</cite> : the surface of the common subject that has been loaded. Something like ‘pial’, ‘white’, or ‘inflated’.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for both hemispheres and white surface of subject1 in the directory defined by the environment variable SUBJECTS_DIR, mapped to fsaverage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_avg</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;surf&#39;</span><span class="p">]</span>
<span class="go">white</span>
</pre></div>
</div>
<p>Here, we are a bit more picky and explicit about what we want to load:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_home</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">user_home</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_avg</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="n">display_surf</span><span class="o">=</span><span class="s1">&#39;inflated&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometime we do not care for the mesh, e.g., we only want the morphometry data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_avg</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="n">load_surface_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.group">
<code class="descclassname">brainload.</code><code class="descname">group</code><span class="sig-paren">(</span><em>measure</em>, <em>surf='white'</em>, <em>hemi='both'</em>, <em>fwhm='10'</em>, <em>subjects_dir=None</em>, <em>average_subject='fsaverage'</em>, <em>group_meta_data=None</em>, <em>subjects_list=None</em>, <em>subjects_file='subjects.txt'</em>, <em>subjects_file_dir=None</em>, <em>custom_morphometry_file_templates=None</em>, <em>subjects_detection_mode='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Load standard space morphometry data for a number of subjects.</p>
<p>Load group data, i.e., morphometry data for all subjects in a study that has already been mapped to standard space and is ready for group analysis.
The information given in the parameters <cite>measure</cite>, <cite>surf</cite>, <cite>hemi</cite>, and <cite>fwhm</cite> are used to construct the file name that will be loaded by default. This function will NOT load the meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Data files for this measure have to exist for all subjects.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>fwhm</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Which averaging version of the data should be loaded. FreeSurfer usually generates different standard space files with a number of smoothing settings. Defaults to ‘10’. If None is passed, the <cite>.fwhmX</cite> part is omitted from the file name completely. Set this to ‘0’ to get the unsmoothed version.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the average subject to which the data was mapped. Defaults to ‘fsaverage’.</li>
<li><strong>group_meta_data</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – A dictionary that should be merged into the return value <cite>group_meta_data</cite>. Defaults to the empty dictionary if omitted.</li>
<li><strong>subjects_list</strong> (list of strings, optional (unless <cite>subjects_detection_mode</cite> is set to <cite>list</cite>)) – A list of subject identifiers or directory names that should be loaded from the <cite>subjects_dir</cite>. Example list: <cite>[‘subject1’, ‘subject2’]</cite>. Defaults to None. Only allowed if <cite>subjects_detection_mode</cite> is <cite>auto</cite> or <cite>list</cite>. In <cite>auto</cite> mode, this takes
precedence over all other options, i.e., if a <cite>subjects_list</cite> <em>and</em> the (default or custom) <cite>subjects_file</cite> are given, the <cite>subjects_list</cite> will be used.</li>
<li><strong>subjects_file_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This directory must contain the <cite>subjects_file</cite> (see below). Defaults to the <cite>subjects_dir</cite>.</li>
<li><strong>subjects_file</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the subjects file, relative to the <cite>subjects_file_dir</cite>. Defaults to ‘subjects.txt’. The file must be a simple text file that contains one <cite>subject_id</cite> per line. It can be a CSV file that has other data following, but the <cite>subject_id</cite> has to be the first item on each line and the separator must be a comma. So a line is allowed to look like this: <cite>subject1, 35, center1, 147</cite>. No header is allowed. If you have a different format, consider reading the file yourself and pass the result as <cite>subjects_list</cite> instead.</li>
<li><strong>custom_morphometry_file_templates</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – <dl class="docutils">
<dt>Cutom filenames for the left and right hemisphere data files that should be loaded. A dictionary of strings with exactly the following two keys: <cite>lh</cite> and <cite>rh</cite>. The value strings can contain hardcoded file names or template strings for them. As always, the files will be loaded relative to the <cite>surf/</cite> directory of the respective subject. Example for hard-coded files: <cite>{‘lh’: ‘lefthemi.nonstandard.mymeasure44.mgh’, ‘rh’: ‘righthemi.nonstandard.mymeasure44.mgh’}</cite>. The strings may contain any of the following variabes, which will be replaced by what you supplied to the other arguments of this function:</dt>
<dd><ul class="first">
<li><cite>${MEASURE}</cite> will be replaced with the value of <cite>measure</cite>.</li>
<li><cite>${SURF}</cite> will be replaced with the FreeSurfer file name part for the surface <cite>surf</cite>. This is the empty string if <cite>surf</cite> is ‘white’, and a dot followed by the value of <cite>surf</cite> for all other settings of surf. Examples: when <cite>surf</cite> is ‘pial’, this will be replaced with ‘.pial’ (Note the dot!). If <cite>surf</cite> is ‘white’, this will be replaced with the empty string.</li>
<li><cite>${SURF_RAW}</cite> will be replaced with the value of <cite>surf</cite>.</li>
<li><cite>${HEMI}</cite> will be replaced with ‘lh’ for the left hemisphere, and with ‘rh’ for the right hemisphere.</li>
<li><cite>${FWHM}</cite> will be replaced with the value of <cite>fwhm</cite>, so something like ‘10’.</li>
<li><cite>${SUBJECT_ID}</cite> will be replaced by the id of the subject that is being loaded, e.g., ‘subject3’.</li>
<li><cite>${AVERAGE_SUBJECT}</cite> will be replaced by the value of <cite>average_subject</cite>.</li>
</ul>
<p class="last">Note that only <cite>${SURF}</cite> and <cite>${HEMI}</cite> are usually needed, everything else can be hardcoded (or is not part of typical FreeSurfer file names at all, like <cite>${SUBJECT_ID}</cite>).
Example template string: <cite>subj_${SUBJECT_ID}_hemi_${HEMI}.alsononstandard.mgh</cite>. Complete example for template strings in dictionary: <cite>{‘lh’: ‘subj_${SUBJECT_ID}_hemi_${HEMI}.alsononstandard.mgh’, ‘rh’: ‘subj_${SUBJECT_ID}_hemi_${HEMI}.alsononstandard.mgh’}</cite>.</p>
</dd>
</dl>
</li>
<li><strong>subjects_detection_mode</strong> (<em>{'auto'</em><em>, </em><em>'list'</em><em>, </em><em>'file'</em><em>, </em><em>'search_dir'}</em><em>, </em><em>optional</em>) – <dl class="docutils">
<dt>The method used to determine the subjects that should be loaded. Defaults to ‘auto’. You can always see which mode was used by looking at the returned <cite>run_meta_data</cite>, see <cite>run_meta_data[‘subjects_detection_mode’]</cite>.</dt>
<dd><ul class="first last">
<li>’auto’: In this mode, all available methods will be tried in the following order: If a <cite>subjects_list</cite> is given, it is used. Then, the <cite>subjects_file</cite> is used if it exists. Note that this may be the default file, ‘$SUBJECTS_DIR/subject_surf_dir.txt’, or another if one has explicitely been defined by setting <cite>subjects_file</cite> and/or <cite>subjects_file_dir</cite>. If the file does not exist, the directory is searched for directories containing FreeSurfer data as defined in the section for ‘search_dir’ mode below. You can always see which method was used in auto mode by looking at the returned <cite>run_meta_data</cite>, see <cite>run_meta_data[‘subjects_detection_mode_auto_used_method’]</cite>.</li>
<li>’list’: In this mode, the given <cite>subjects_list</cite> is used, and you have to supply one. If not, an error is raised. You are not allowed to supply a <cite>subjects_file</cite> in this mode, or an error will be raised.</li>
<li>’file’: In this mode, the subjects file is used. Note that this may be the default file, ‘$SUBJECTS_DIR/subjects.txt’, or another if one has explicitely been defined by setting <cite>subjects_file</cite> and/or <cite>subjects_file_dir</cite>. If the file does not exist, an error is raised. You can see which file was used by looking at the returned <cite>run_meta_data</cite>, see <cite>run_meta_data[‘subjects_file’]</cite>. You are not allowed to supply a <cite>subjects_list</cite> in this mode, or an error will be raised.</li>
<li>’search_dir’: In this mode, the <cite>subjects_dir</cite> (default or explicitely given) is searched for sub directories which look as if they could contain FreeSurfer data. The latter means that they contain a sub directory named ‘surf’. There is one exception though: if the name of one such directory equals the name of the <cite>average_subject</cite>, the directory is skipped. You are not allowed to supply a <cite>subjects_list</cite> in this mode, or an error will be raised.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>group_morphometry_data</strong> (<em>numpy array</em>) – An array filled with the morphometry data for the subjects. The array has shape <cite>(n, m)</cite> where <cite>n</cite> is the number of subjects, and <cite>m</cite> is the number of vertices of the standard subject. (If you load both hemispheres instead of one, m doubles.) To get the subject id for the entries, look at the respective index in the returned <cite>subjects_list</cite>.</li>
<li><strong>subjects_list</strong> (<em>list of strings</em>) – A list containing the subject identifiers in the same order as the data in <cite>group_morphometry_data</cite>. (If <cite>subjects_detection_mode</cite> is ‘list’ or ‘file’, the order in these is guaranteed to be preserved. But in mode ‘search_dir’ or ‘auto’ which may have chosen to fall back to ‘search_dir’ as a last resort, this is helpful: You can use the index of a subject in this list to find its data in <cite>group_morphometry_data</cite>, as it will have the same index. See the examples below.)</li>
<li><strong>group_meta_data</strong> (<em>dictionary</em>) – A dictionary containing detailed information on all subjects and files that were loaded. Each of its keys is a subject identifier. The data value is another dictionary that contains all meta data for this subject as returned by the <cite>subject_avg</cite> function.</li>
<li><strong>run_meta_data</strong> (<em>dictionary</em>) – A dictionary containing general information on the settings used when executing the function and determining which subjects to load.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for all subjects in the directory defined by the environment variable SUBJECTS_DIR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">group_md</span><span class="p">,</span> <span class="n">run_md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;area&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we load curv data for the right hemisphere, computed on the pial surface with smooting of 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">group_md</span><span class="p">,</span> <span class="n">run_md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">surf</span><span class="o">=</span><span class="s1">&#39;pial&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;20&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We may want to be a but more explicit on which subjects are loaded from where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;subject4&#39;</span><span class="p">,</span> <span class="s1">&#39;subject8&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">group_md</span><span class="p">,</span> <span class="n">run_md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;20&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">,</span> <span class="n">subjects_list</span><span class="o">=</span><span class="n">subjects_list</span><span class="p">)</span>
</pre></div>
</div>
<p>Continuing the last example, we may want to have a look at the curv value of the vertex at index 100000 of the subject ‘subject4’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subject4_idx</span> <span class="o">=</span> <span class="n">subjects</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;subject4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">data</span><span class="p">[</span><span class="n">subject4_idx</span><span class="p">][</span><span class="mi">100000</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.group_native">
<code class="descclassname">brainload.</code><code class="descname">group_native</code><span class="sig-paren">(</span><em>measure</em>, <em>subjects_dir</em>, <em>subjects_list</em>, <em>surf='white'</em>, <em>hemi='both'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.group_native" title="Permalink to this definition">¶</a></dt>
<dd><p>Load native space morphometry data for a number of subjects.</p>
<p>Load native space group data, i.e., morphometry data for all subjects in a study.
The information given in the parameters <cite>measure</cite>, <cite>surf</cite>, and <cite>hemi</cite> are used to construct the file name that will be loaded by default. This function will NOT load the meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Data files for this measure have to exist for all subjects.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. Defaults to ‘white’. Will be added after the measure name unless left at default.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>subjects_list</strong> (list of strings, optional (unless <cite>subjects_detection_mode</cite> is set to <cite>list</cite>)) – A list of subject identifiers or directory names that should be loaded from the <cite>subjects_dir</cite>. Example list: <cite>[‘subject1’, ‘subject2’]</cite>. Defaults to None. Only allowed if <cite>subjects_detection_mode</cite> is <cite>auto</cite> or <cite>list</cite>. In <cite>auto</cite> mode, this takes
precedence over all other options, i.e., if a <cite>subjects_list</cite> <em>and</em> the (default or custom) <cite>subjects_file</cite> are given, the <cite>subjects_list</cite> will be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>morphdata_by_subject</strong> (<em>dictionary</em>) – A dictionary containing the morphometry data. Keys are subject identifiers, and values are the morphometry data numpy 1D arrays.</li>
<li><strong>group_meta_data</strong> (<em>dictionary</em>) – A dictionary containing detailed information on all subjects and files that were loaded. Each of its keys is a subject identifier. The data value is another dictionary that contains all meta data for this subject.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.fsaverage_mesh">
<code class="descclassname">brainload.</code><code class="descname">fsaverage_mesh</code><span class="sig-paren">(</span><em>subject_id='fsaverage'</em>, <em>surf='white'</em>, <em>hemi='both'</em>, <em>subjects_dir=None</em>, <em>use_freesurfer_home_if_missing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.fsaverage_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a surface mesh of the fsaverage subject.</p>
<p>Convenience function to load a FreeSurfer surface mesh of the fsaverage subject. Use the subject_mesh function to load the mesh of any other subject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em><em>, </em><em>optional</em>) – The subject identifier of the subject. Defaults to ‘fsaverage’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>use_freesurfer_home_if_missing</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If set to True, first checks whether the directory for the given subject exists in the <cite>subjects_dir</cite>. If it does not, it will reset the <cite>subjects_dir</cite> to ‘${FREESURFER_HOME}/subjects’ before proceeding.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for both hemispheres and white surface of subject1 in the directory defined by the environment variable SUBJECTS_DIR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faced</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">fsaverage_mesh</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.subject_mesh">
<code class="descclassname">brainload.</code><code class="descname">subject_mesh</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>surf='white'</em>, <em>hemi='both'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.subject_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a surface mesh of a subject.</p>
<p>Convenience function to load a FreeSurfer surface mesh of a subject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load the pial surface mesh for both hemispheres of the Freeurfer example subject bert:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span><span class="o">,</span> <span class="nn">import</span> <span class="n">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;Applications&#39;</span><span class="p">,</span> <span class="s1">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s1">&#39;subjects&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faced</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_mesh</span><span class="p">(</span><span class="s1">&#39;bert&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="n">surf</span><span class="o">=</span><span class="s1">&#39;pial&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.rhi">
<code class="descclassname">brainload.</code><code class="descname">rhi</code><span class="sig-paren">(</span><em>rh_relative_index</em>, <em>meta_data</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.rhi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the absolute data index given an index relative to the right hemisphere.</p>
<p>This function makes sense only given a <cite>morphometry_data</cite> and associated <cite>meta_data</cite> that contains data on two hemispheres (even though the <cite>morphometry_data</cite> array itself is not passed to this function). E.g., the return value of a function like <cite>subject()</cite> or <cite>subject_avg()</cite> when called with <cite>hemi=’both’</cite>. For such data, it computes the absolute index in the data given a request index relative to the right hemisphere. The name is short for ‘right hemisphere index’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rh_relative_index</strong> (<em>int</em>) – An index relative to the right hemisphere. E.g., <cite>0</cite> if you want to get the index of the first vertex of the right hemisphere. Its absolute value must be between 0 and the number of vertices of the right hemisphere. Negative values are allowed, and <cite>-1</cite> will get you the second-to-last possible index, <cite>-2</cite> the third-to-last, and so on.</li>
<li><strong>meta_data</strong> (<em>dictionary</em>) – The meta data dictionary returned for your data. It must contain the keys ‘lh.num_data_points’ and ‘rh.num_data_points’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The absolute index into the data for the given <cite>rh_relative_index</cite>.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;heinz&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;rh value at index 10, relative to start of right hemisphere: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">morphometry_data</span><span class="p">[</span><span class="n">bl</span><span class="o">.</span><span class="n">rhi</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.rhv">
<code class="descclassname">brainload.</code><code class="descname">rhv</code><span class="sig-paren">(</span><em>rh_relative_index</em>, <em>morphometry_data</em>, <em>meta_data</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.rhv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value in <cite>morphometry_data</cite> at an index relative to the right hemisphere.</p>
<p>This function makes sense only given a <cite>morphometry_data</cite> and associated <cite>meta_data</cite> that contains data on two hemispheres. E.g., the return value of a function like <cite>subject()</cite> or <cite>subject_avg()</cite> when called with <cite>hemi=’both’</cite>. For such data, it returns the value in <cite>morphometry_data</cite> at a request index given relative to the right hemisphere. The name is short for ‘right hemisphere value’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rh_relative_index</strong> (<em>int</em>) – An index relative to the start of the right hemisphere in the data. E.g., <cite>0</cite> if you want to get the value for the first vertex of the right hemisphere. Its absolute value must be between 0 and the number of vertices of the right hemisphere. Negative values are allowed, and <cite>-1</cite> will get you the last possible value, <cite>-2</cite> the second-to-last, and so on.</li>
<li><strong>morphometry_data</strong> (<em>numpy array</em>) – The morphometry data array, must represent data for both hemispheres.</li>
<li><strong>meta_data</strong> (<em>dictionary</em>) – The meta data dictionary returned for your data. It must contain the keys ‘lh.num_data_points’ and ‘rh.num_data_points’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The value at the given index that is relative to the start of the right hemisphere in the data.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;heinz&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;rh value at index 10, relative to start of right hemisphere: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">bl</span><span class="o">.</span><span class="n">rhv</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.hemi_range">
<code class="descclassname">brainload.</code><code class="descname">hemi_range</code><span class="sig-paren">(</span><em>morphometry_meta_data</em>, <em>hemi</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.hemi_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute start and end index in the hemisphere data for the given hemisphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>morphometry_meta_data</strong> (dictionary as returned by the functions that read morphometry data (e.g., <code class="docutils literal notranslate"><span class="pre">`subject_data_native`</span></code>).) – </li>
<li><strong>hemi</strong> (<em>string</em><em>, </em><em>one of 'lh'</em><em> or </em><em>'rh'. The hemisphere you want to get the start and end index for.</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>start_index</strong> (<em>integer</em>) – The start index of the lh data.</li>
<li><strong>end_index</strong> (<em>integer</em>) – The end index of the lh data.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_data_native</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;/mnt/study1_data&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">hemi_range</span><span class="p">(</span><span class="n">meta_data</span><span class="p">,</span> <span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean lh thickness value is: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">morphometry_data</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">])))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.annot">
<code class="descclassname">brainload.</code><code class="descname">annot</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>annotation</em>, <em>hemi='both'</em>, <em>meta_data=None</em>, <em>orig_ids=False</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annot" title="Permalink to this definition">¶</a></dt>
<dd><p>Load annotation for the mesh vertices of a single subject.</p>
<p>An annotation defines a label string and a color to each vertex, it is typically used to define brain regions, e.g., for cortical parcellation. An annotation consists of several groups of vertices, each of which is assigned a label and a color.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier.</li>
<li><strong>subject_dir</strong> (<em>string</em>) – A string representing the path to the subjects dir.</li>
<li><strong>annotation</strong> (<em>string</em>) – An annotation to load, part of the file name of the respective file in the subjects label directory. E.g., ‘aparc’, ‘aparc.a2009s’, or ‘aparc.DKTatlas’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere for which data should actually be loaded. Defaults to ‘both’.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
<li><strong>orig_ids</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Passed on to nibabel.freesurfer.io.read_annot function. From the documentation of that function: ‘Whether to return the vertex ids as stored in the annotation file or the positional colortable ids. With orig_ids=False vertices with no id have an id set to -1.’ Defaults to False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>vertex_labels</strong> (<em>ndarray, shape (n_vertices,)</em>) – If orig_ids is False (the default), returns the index (for each vertex) into the label_colors and label_names datastructures to retrieve the color and name. If some vertex has no annotation, -1 is returned for it.</p>
<p>If orig_ids is True, returns an annotation color id for each vertex listed in the annotation file. IMPORTANT: The annotation value in here is NOT the label id. It is a code based on the color for the vertex. Yes, this is ugly. See <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles#Annotation">https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles#Annotation</a> for details, especially the section ‘Annotation file design surprise’. The color is encoded as a single number. Quoting the linked document, the numer is the ‘RGB value combined into a single 32-bit integer: annotation value = (B * 256^2) + (G * 256) + (R)’. From this it follows that, quoting the doc once more, ‘Code that loads an annotation file … has to compare annotation values to the color values in the ColorLUT part of the annotation file to discover what parcellation label code (ie: structure code) corresponds.’ (Basically this has already been done for you if you simply set orig_ids to False.)</p>
</li>
<li><p class="first"><strong>label_colors</strong> (<em>ndarray, shape (n_labels, 5)</em>) – RGBT + label id colortable array. The first 4 values encode the label color: RGB is red, green, blue as usual, from 0 to 255 per value. T is the transparency, which is defined as 255 - alpha. The last value represents the label id. The number of labels (n_label) cannot be know in advance by this function in the general case (but the user can know based on the Atlas he is loading, e.g., the Desikan-Killiany Atlas has 36 labels).</p>
</li>
<li><p class="first"><strong>label_names</strong> (<em>list of strings</em>) – The names of the labels. The length of the list is n_labels. Note that, contrary to the respective nibabel function, this function will always return this as a list of strings, no matter the Python version used.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.annotation_file</cite> : the file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load cortical parcellation annotations for both hemispheres of a subject from the Desikan-Killiany (‘aparc’) atlas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_labels</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">,</span> <span class="n">label_names</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">annot</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;aparc&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.aparc.annot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;rh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/rh.aparc.annot</span>
</pre></div>
</div>
<p>Now load cortical parcellation annotations for the left hemisphere of a subject from the Destrieux (‘aparc.a2009s’) atlas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_labels</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">,</span> <span class="n">label_names</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">annot</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;aparc.a2009s&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.aparc.a2009s.annot</span>
</pre></div>
</div>
<p>Now load cortical parcellation annotations for the right hemisphere of a subject from the DKT (‘aparc.DKTatlas40’) atlas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_labels</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">,</span> <span class="n">label_names</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">annot</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;aparc.DKTatlas40&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;rh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.aparc.DKTatlas40.annot</span>
</pre></div>
</div>
<p>Print the color and the annotation name for an example vertex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vert_idx</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c1"># We&#39;ll take the first vertex as an example.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">vertex_labels</span><span class="p">[</span><span class="n">vert_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>     <span class="c1"># it is -1 if the vertex is not assigned any label/color</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">vertex_labels</span><span class="p">[</span><span class="n">vert_idx</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span> <span class="s2">&quot;label for vertex </span><span class="si">%d</span><span class="s2"> is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vert_idx</span><span class="p">,</span> <span class="n">label_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span> <span class="s2">&quot;color for vertex </span><span class="si">%d</span><span class="s2"> in RGBA is (</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vert_idx</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Atlas information is available at <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation">https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation</a></p>
</dd></dl>

<dl class="function">
<dt id="brainload.label">
<code class="descclassname">brainload.</code><code class="descname">label</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>label</em>, <em>hemi='both'</em>, <em>meta_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Load annotation for the mesh vertices of a single subject.</p>
<p>An annotation defines a label string and a color to each vertex, it is typically used to define brain regions, e.g., for cortical parcellation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier.</li>
<li><strong>subject_dir</strong> (<em>string</em>) – A string representing the path to the subjects dir.</li>
<li><strong>label</strong> (<em>string</em>) – A label to load, part of the file name of the respective file in the subjects label directory. E.g., ‘cortex’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere for which data should actually be loaded. Defaults to ‘both’.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional if hemi is 'lh'</em><em> or </em><em>'rh'</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary. If ‘hemi’ is ‘both’, this dictionary is required and MUST contain at least one of the keys ‘lh.num_vertices’ or ‘lh.num_data_points’, the value of which must contain the number of vertices of the left hemisphere of the subject. Background: If hemi is ‘both’, the vertex indices of both hemispheres are merged in the return value verts_in_label, and thus we need to know the shift, i.e., the number of vertices in the left hemisphere.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>verts_in_label</strong> (<em>ndarray, shape (n_vertices,)</em>) – Contains the ids of all vertices included in the label.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.label_file</cite> : the file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load the cortex label for the left hemisphere of a subject:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts_in_label</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;cortex&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.label_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.cortex.label</span>
</pre></div>
</div>
<p>You could now use the label information to mask your morphology data.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">mask_data_using_label()</span></code></dt>
<dd>Mask data using a label.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.stat">
<code class="descclassname">brainload.</code><code class="descname">stat</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Read information from a FreeSurfer stats file.</p>
<p>Read information from a FreeSurfer stats file, e.g., <cite>subject/stats/lh.aparc.stats</cite> or <cite>aseg.stats</cite>. A stats file is a text file that contains a data table and various meta data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_name</strong> (<em>string</em>) – The path to the stats file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>The result dictionary, containing the following 4 keys:</dt>
<dd><ul class="first last simple">
<li>’ignored_lines’: list of strings. The list of lines that were not parsed in a special way. This is raw data.</li>
<li>’measures’: string list of dimension (n, m) if there are n measures with m properties each stored in the stats file.</li>
<li>’table_data’: string list of dimension (i, j) when there are i lines containing j values each in the table stored in the stats file. You may want to convert the columns to the proper data types and put the result into several numpy arrays or a single Pandas data frame.</li>
<li>’table_column_headers’: string list. The names for the columns for the table_data. This information is parsed from the table_meta_data and given here for convenience.</li>
<li>’table_meta_data’: dictionary. The full table_meta_data. Stores properties in key, value sub dictionaries. For simple table properties, the dictionaries are keys of the returned dictionary. The only exception is the information on the table columns (header data). This information can be found under the key <cite>column_info_</cite>, which contains one dictionary for each column. In these dictionaries, data is stored as explained for simple table properties.</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dictionary of strings (includes nested sub dicts)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Read the <cite>aseg.stats</cite> file for a subject:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="s1">&#39;/path/to/study/subject1/stats/aseg.stats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Collect some data, just to show the data structures.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;measures&#39;</span><span class="p">]))</span>    <span class="c1"># Will print the number of measures.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;measures&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1">#  Print all data on the first measure.</span>
</pre></div>
</div>
<p>Now lets print the table_data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_data_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_data&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_entries_per_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>And get some information on the table columns (the table header):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_meta_data&#39;</span><span class="p">][</span><span class="s1">&#39;NTableCols&#39;</span><span class="p">]</span>   <span class="c1"># will print &quot;10&quot; (from a simple table property stored directly in the dictionary).</span>
</pre></div>
</div>
<p>Get the names of all the data columns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_column_headers&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Get the name of the first column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">first_column_name</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_column_headers&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>More detailed information on the individual columns can be found under the special <cite>column_info_</cite> key if needed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">column2_info_dict</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_meta_data&#39;</span><span class="p">][</span><span class="s1">&#39;column_info_&#39;</span><span class="p">][</span><span class="s1">&#39;2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">column2_info_dict</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">])</span>          <span class="c1"># will print the value</span>
</pre></div>
</div>
<p>Note that all data is returned as string type, you will need to covert it to float (or whatever) yourself.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.mesh_to_ply">
<code class="descclassname">brainload.</code><code class="descname">mesh_to_ply</code><span class="sig-paren">(</span><em>vertex_coords</em>, <em>faces</em>, <em>vertex_colors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.mesh_to_ply" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a PLY format string of a mesh.</p>
<p>Write a PLY format string of a mesh. See <a class="reference external" href="http://paulbourke.net/dataformats/ply/">http://paulbourke.net/dataformats/ply/</a> for details on the format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vertex_coords</strong> (<em>numpy array of floats</em>) – A 2D array containing 3 coordinates for each vertex. Dimension is (n, 3) for n vertices.</li>
<li><strong>faces</strong> (<em>numpy array of integers</em>) – A 2D array containing 3 vertex indices per face. Dimension is (m, 3) for m faces.</li>
<li><strong>vertex_colors</strong> (<em>numpy array</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – A 2D array with shape (n, 4) assigning a color to each vertex (for the n vertices in vertex_coords). The 4 values in each column define the 4 channels of an RGBA color. Channel values should be given as integers in range 0..255. If omitted, no vertex colors will be included in the PLY format string.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The PLY format string for the mesh.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.mesh_to_obj">
<code class="descclassname">brainload.</code><code class="descname">mesh_to_obj</code><span class="sig-paren">(</span><em>vertex_coords</em>, <em>faces</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.mesh_to_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an OBJ format string of a mesh.</p>
<p>Write an OBJ PLY format string of a mesh. The format is the Wavefront object format, see <cite>https://en.wikipedia.org/wiki/Wavefront_.obj_file</cite> for details. This exporter only writes the geometry, vertex colors are not a standard OBJ feature and are not included. Use mesh_to_ply to get vertex colors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vertex_coords</strong> (<em>numpy array of floats</em>) – A 2D array containing 3 coordinates for each vertex. Dimension is (n, 3) for n vertices.</li>
<li><strong>faces</strong> (<em>numpy array of integers</em>) – A 2D array containing 3 vertex indices per face. Dimension is (m, 3) for m faces.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The OBJ format string for the mesh.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.read_subjects_file">
<code class="descclassname">brainload.</code><code class="descname">read_subjects_file</code><span class="sig-paren">(</span><em>subjects_file</em>, <em>has_header_line=False</em>, <em>index_of_subject_id_field=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.read_subjects_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a subjects file in CSV format that has the subject id as the first entry on each line. Arbitrary data may follow in the consecutive fields on each line, and will be ignored. Having nothing but the subject id on the line is also fine, of course.</p>
<p>The file can be a simple text file that contains one <cite>subject_id</cite> per line. It can also be a CSV file that has other data following, but the <cite>subject_id</cite> has to be the first item on each line and the separator must be a comma. So a line is allowed to look like this: <cite>subject1, 35, center1, 147</cite>. No header is allowed. If you have a different format, consider reading the file yourself and pass the result as <cite>subjects_list</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_file</strong> (<em>string</em>) – Path to a subjects file (see above for format details).</li>
<li><strong>has_header_line</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether the first line is a header line and should be skipped. Defaults to ‘False’.</li>
<li><strong>index_of_subject_id_field</strong> (<em>integer</em><em>, </em><em>optional</em>) – The column index of the field that contains the subject id in each row. Defaults to ‘0’. Changing this only makes sense for CSV files.</li>
<li><strong>**kwargs</strong> (<em>any</em>) – Any other named arguments will be passed on to the call to the call to the <cite>csv.reader</cite> constructor. That is a class from Python’s standard <cite>csv</cite> module. Example: pass <cite>delimiter=’    ‘</cite> if your CSV file is limited by tabs.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of subject identifiers.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load a list of subjects from a simple text file that contains one subject per line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_ids</span> <span class="o">=</span> <span class="n">nit</span><span class="o">.</span><span class="n">read_subjects_file</span><span class="p">(</span><span class="s1">&#39;/home/myuser/data/study5/subjects.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">brainload.</code><code class="descname">read_subjects_file</code><span class="sig-paren">(</span><em>subjects_file</em>, <em>has_header_line=False</em>, <em>index_of_subject_id_field=0</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Read a subjects file in CSV format that has the subject id as the first entry on each line. Arbitrary data may follow in the consecutive fields on each line, and will be ignored. Having nothing but the subject id on the line is also fine, of course.</p>
<p>The file can be a simple text file that contains one <cite>subject_id</cite> per line. It can also be a CSV file that has other data following, but the <cite>subject_id</cite> has to be the first item on each line and the separator must be a comma. So a line is allowed to look like this: <cite>subject1, 35, center1, 147</cite>. No header is allowed. If you have a different format, consider reading the file yourself and pass the result as <cite>subjects_list</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_file</strong> (<em>string</em>) – Path to a subjects file (see above for format details).</li>
<li><strong>has_header_line</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether the first line is a header line and should be skipped. Defaults to ‘False’.</li>
<li><strong>index_of_subject_id_field</strong> (<em>integer</em><em>, </em><em>optional</em>) – The column index of the field that contains the subject id in each row. Defaults to ‘0’. Changing this only makes sense for CSV files.</li>
<li><strong>**kwargs</strong> (<em>any</em>) – Any other named arguments will be passed on to the call to the call to the <cite>csv.reader</cite> constructor. That is a class from Python’s standard <cite>csv</cite> module. Example: pass <cite>delimiter=’    ‘</cite> if your CSV file is limited by tabs.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of subject identifiers.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load a list of subjects from a simple text file that contains one subject per line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_ids</span> <span class="o">=</span> <span class="n">nit</span><span class="o">.</span><span class="n">read_subjects_file</span><span class="p">(</span><span class="s1">&#39;/home/myuser/data/study5/subjects.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.detect_subjects_in_directory">
<code class="descclassname">brainload.</code><code class="descname">detect_subjects_in_directory</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>ignore_dir_names=None</em>, <em>required_subdirs_for_hits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.detect_subjects_in_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for directories containing FreeSurfer output in a directory and return the subject names.</p>
<p>Given a directory, search its sub directories for FreeSurfer data and return the directory names of all directories in which such data was found. The resulting list can be used
to create a subjects.txt file. This method searches all direct sub directories of the given subjects_dir for the existance of the typical FreeSurfer output directory structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_dir</strong> (<em>string</em>) – Path to a subjects directory.</li>
<li><strong>ignore_dir_names</strong> (<em>list of strings | None</em><em>, </em><em>optional</em>) – A list of directory names that should be ignored, even if they have the required sub directories. This is useful if you do not want to load certain subjects. It is often used to avoid loading the average subject ‘fsaverage’. Defaults to a list with the single element ‘fsaverage’. You can explicitely pass an empty list if you want to include all subjects.</li>
<li><strong>required_subdirs_for_hits</strong> (<em>list of strings | None</em>) – A sub directory of the given <cite>subjects_dir</cite> is considered a subject if it contains the typical FreeSurfer directory structure. Which sub directories are required is determined by this argument. If all of them are found under a dir, that dir is added tp the output list. This list defaults to a list with the single element ‘surf’. If that leads to false positives in your case, you could pass something like <cite>[‘surf’, ‘mri’, ‘label’]</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of the subject identifiers (or directories that were considered as such).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Guess which directories under the current SUBJECTS_DIR contain subject data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_subject_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;SUBJECTS_DIR&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_ids</span> <span class="o">=</span> <span class="n">nit</span><span class="o">.</span><span class="n">detect_subjects_in_directory</span><span class="p">(</span><span class="n">my_subject_dir</span><span class="p">,</span> <span class="n">ignore_dir_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fsaverage&#39;</span><span class="p">,</span> <span class="s1">&#39;Copy of subject4&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.subject_data_native">
<code class="descclassname">brainload.</code><code class="descname">subject_data_native</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>measure</em>, <em>hemi</em>, <em>surf='white'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.subject_data_native" title="Permalink to this definition">¶</a></dt>
<dd><p>Load native space morphometry data for a subject (e.g., lh.area).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Defaults to ‘area’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. For white, nothing will be added. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em>) – The hemisphere that should be loaded.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. Note that the two hemispheres do in general NOT have the same number of vertices.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘subject’. This means that the data loaded represent morphometry data taken from the subject’s surface (as opposed to data mapped to a common or average subject).</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_data_native</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;/mnt/study1_data&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.subject_data_standard">
<code class="descclassname">brainload.</code><code class="descname">subject_data_standard</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>measure</em>, <em>hemi</em>, <em>fwhm</em>, <em>average_subject='fsaverage'</em>, <em>surf='white'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.subject_data_standard" title="Permalink to this definition">¶</a></dt>
<dd><p>Load standard space data for a subject (e.g., lh.area.fwhm10.fsaverage.mgh).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em>) – The hemisphere that should be loaded.</li>
<li><strong>fwhm</strong> (<em>string</em><em> or </em><em>None</em>) – Which averaging version of the data should be loaded. FreeSurfer usually generates different standard space files with a number of smoothing settings. If None is passed, the <cite>.fwhmX</cite> part is omitted from the file name completely. Set this to ‘0’ to get the unsmoothed version.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study.</li>
<li><strong>average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the average subject to which the data was mapped. Defaults to ‘fsaverage’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. Note that the two hemispheres do in general NOT have the same number of vertices.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘common’. This means that the data loaded represent morphometry data that has been mapped to a common or average subject.</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-brainload.freesurferdata">
<span id="brainload-freesurferdata-module"></span><h2>brainload.freesurferdata module<a class="headerlink" href="#module-brainload.freesurferdata" title="Permalink to this headline">¶</a></h2>
<p>Functions for loading FreeSurfer data on different levels.</p>
<p>The high-level functions are available directly in the package namespace. Using the functions in here should not be necessary.</p>
<dl class="function">
<dt id="brainload.freesurferdata.fsaverage_mesh">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">fsaverage_mesh</code><span class="sig-paren">(</span><em>subject_id='fsaverage'</em>, <em>surf='white'</em>, <em>hemi='both'</em>, <em>subjects_dir=None</em>, <em>use_freesurfer_home_if_missing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.fsaverage_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a surface mesh of the fsaverage subject.</p>
<p>Convenience function to load a FreeSurfer surface mesh of the fsaverage subject. Use the subject_mesh function to load the mesh of any other subject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em><em>, </em><em>optional</em>) – The subject identifier of the subject. Defaults to ‘fsaverage’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>use_freesurfer_home_if_missing</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If set to True, first checks whether the directory for the given subject exists in the <cite>subjects_dir</cite>. If it does not, it will reset the <cite>subjects_dir</cite> to ‘${FREESURFER_HOME}/subjects’ before proceeding.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for both hemispheres and white surface of subject1 in the directory defined by the environment variable SUBJECTS_DIR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faced</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">fsaverage_mesh</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.get_morphometry_file_path">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">get_morphometry_file_path</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>subject_id</em>, <em>surf</em>, <em>hemi</em>, <em>measure</em>, <em>subdir='surf'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.get_morphometry_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the path to a native space morphometry file, e.g., <cite>lh.area</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.get_num_fsaverage_verts_per_hemi">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">get_num_fsaverage_verts_per_hemi</code><span class="sig-paren">(</span><em>fsversion=6</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.get_num_fsaverage_verts_per_hemi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of vertices per fsaverage hemisphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>vertcount</strong> – The number of vertices per fsaverage hemisphere.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.get_standard_space_morphometry_file_path">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">get_standard_space_morphometry_file_path</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>subject_id</em>, <em>hemi</em>, <em>measure</em>, <em>fwhm='10'</em>, <em>average_subject='fsaverage'</em>, <em>surf='white'</em>, <em>subdir='surf'</em>, <em>file_ext='mgh'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.get_standard_space_morphometry_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the path to a standard space morphometry file, e.g., <cite>lh.area.fwhm10.fsaverage.mgh</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.get_surface_file_path">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">get_surface_file_path</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>subject_id</em>, <em>hemi</em>, <em>surf</em>, <em>subdir='surf'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.get_surface_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the path to a surface file, e.g., <cite>lh.white</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.get_vox2ras_and_ras2vox_from_nifti_file">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">get_vox2ras_and_ras2vox_from_nifti_file</code><span class="sig-paren">(</span><em>nifti_file</em>, <em>use_sform=True</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.get_vox2ras_and_ras2vox_from_nifti_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the vox2ras and ras2vox matrices from a nifti file header.</p>
<p>Load the vox2ras and ras2vox matrices from a nifti file header. The file can be in nifti (.nii) or gzipped nifti (.nii.gz) format. To understand qform and sform, read the nibabel docs or better <a class="reference external" href="https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/Orientation%20Explained">https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/Orientation%20Explained</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nifti_file</strong> (<em>str</em>) – Path to a nifti or gzipped nifti file.</li>
<li><strong>use_sform</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to report the sform matrix or qform matrix from the nifti header. Defaults to True (=sform). If set to False, the qform will be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>vox2ras</strong> (<em>2D numpy array</em>) – The sform or qform matrix</li>
<li><strong>ras2vox</strong> (<em>2D numpy array</em>) – The inverse of the vox2ras matrix.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vox2ras</span><span class="p">,</span> <span class="n">ras2vox</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">get_vox2ras_and_ras2vox_from_nifti_file</span><span class="p">(</span><span class="s2">&quot;mni152_volume.nii.gz&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.group">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">group</code><span class="sig-paren">(</span><em>measure</em>, <em>surf='white'</em>, <em>hemi='both'</em>, <em>fwhm='10'</em>, <em>subjects_dir=None</em>, <em>average_subject='fsaverage'</em>, <em>group_meta_data=None</em>, <em>subjects_list=None</em>, <em>subjects_file='subjects.txt'</em>, <em>subjects_file_dir=None</em>, <em>custom_morphometry_file_templates=None</em>, <em>subjects_detection_mode='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Load standard space morphometry data for a number of subjects.</p>
<p>Load group data, i.e., morphometry data for all subjects in a study that has already been mapped to standard space and is ready for group analysis.
The information given in the parameters <cite>measure</cite>, <cite>surf</cite>, <cite>hemi</cite>, and <cite>fwhm</cite> are used to construct the file name that will be loaded by default. This function will NOT load the meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Data files for this measure have to exist for all subjects.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>fwhm</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Which averaging version of the data should be loaded. FreeSurfer usually generates different standard space files with a number of smoothing settings. Defaults to ‘10’. If None is passed, the <cite>.fwhmX</cite> part is omitted from the file name completely. Set this to ‘0’ to get the unsmoothed version.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the average subject to which the data was mapped. Defaults to ‘fsaverage’.</li>
<li><strong>group_meta_data</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – A dictionary that should be merged into the return value <cite>group_meta_data</cite>. Defaults to the empty dictionary if omitted.</li>
<li><strong>subjects_list</strong> (list of strings, optional (unless <cite>subjects_detection_mode</cite> is set to <cite>list</cite>)) – A list of subject identifiers or directory names that should be loaded from the <cite>subjects_dir</cite>. Example list: <cite>[‘subject1’, ‘subject2’]</cite>. Defaults to None. Only allowed if <cite>subjects_detection_mode</cite> is <cite>auto</cite> or <cite>list</cite>. In <cite>auto</cite> mode, this takes
precedence over all other options, i.e., if a <cite>subjects_list</cite> <em>and</em> the (default or custom) <cite>subjects_file</cite> are given, the <cite>subjects_list</cite> will be used.</li>
<li><strong>subjects_file_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This directory must contain the <cite>subjects_file</cite> (see below). Defaults to the <cite>subjects_dir</cite>.</li>
<li><strong>subjects_file</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the subjects file, relative to the <cite>subjects_file_dir</cite>. Defaults to ‘subjects.txt’. The file must be a simple text file that contains one <cite>subject_id</cite> per line. It can be a CSV file that has other data following, but the <cite>subject_id</cite> has to be the first item on each line and the separator must be a comma. So a line is allowed to look like this: <cite>subject1, 35, center1, 147</cite>. No header is allowed. If you have a different format, consider reading the file yourself and pass the result as <cite>subjects_list</cite> instead.</li>
<li><strong>custom_morphometry_file_templates</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – <dl class="docutils">
<dt>Cutom filenames for the left and right hemisphere data files that should be loaded. A dictionary of strings with exactly the following two keys: <cite>lh</cite> and <cite>rh</cite>. The value strings can contain hardcoded file names or template strings for them. As always, the files will be loaded relative to the <cite>surf/</cite> directory of the respective subject. Example for hard-coded files: <cite>{‘lh’: ‘lefthemi.nonstandard.mymeasure44.mgh’, ‘rh’: ‘righthemi.nonstandard.mymeasure44.mgh’}</cite>. The strings may contain any of the following variabes, which will be replaced by what you supplied to the other arguments of this function:</dt>
<dd><ul class="first">
<li><cite>${MEASURE}</cite> will be replaced with the value of <cite>measure</cite>.</li>
<li><cite>${SURF}</cite> will be replaced with the FreeSurfer file name part for the surface <cite>surf</cite>. This is the empty string if <cite>surf</cite> is ‘white’, and a dot followed by the value of <cite>surf</cite> for all other settings of surf. Examples: when <cite>surf</cite> is ‘pial’, this will be replaced with ‘.pial’ (Note the dot!). If <cite>surf</cite> is ‘white’, this will be replaced with the empty string.</li>
<li><cite>${SURF_RAW}</cite> will be replaced with the value of <cite>surf</cite>.</li>
<li><cite>${HEMI}</cite> will be replaced with ‘lh’ for the left hemisphere, and with ‘rh’ for the right hemisphere.</li>
<li><cite>${FWHM}</cite> will be replaced with the value of <cite>fwhm</cite>, so something like ‘10’.</li>
<li><cite>${SUBJECT_ID}</cite> will be replaced by the id of the subject that is being loaded, e.g., ‘subject3’.</li>
<li><cite>${AVERAGE_SUBJECT}</cite> will be replaced by the value of <cite>average_subject</cite>.</li>
</ul>
<p class="last">Note that only <cite>${SURF}</cite> and <cite>${HEMI}</cite> are usually needed, everything else can be hardcoded (or is not part of typical FreeSurfer file names at all, like <cite>${SUBJECT_ID}</cite>).
Example template string: <cite>subj_${SUBJECT_ID}_hemi_${HEMI}.alsononstandard.mgh</cite>. Complete example for template strings in dictionary: <cite>{‘lh’: ‘subj_${SUBJECT_ID}_hemi_${HEMI}.alsononstandard.mgh’, ‘rh’: ‘subj_${SUBJECT_ID}_hemi_${HEMI}.alsononstandard.mgh’}</cite>.</p>
</dd>
</dl>
</li>
<li><strong>subjects_detection_mode</strong> (<em>{'auto'</em><em>, </em><em>'list'</em><em>, </em><em>'file'</em><em>, </em><em>'search_dir'}</em><em>, </em><em>optional</em>) – <dl class="docutils">
<dt>The method used to determine the subjects that should be loaded. Defaults to ‘auto’. You can always see which mode was used by looking at the returned <cite>run_meta_data</cite>, see <cite>run_meta_data[‘subjects_detection_mode’]</cite>.</dt>
<dd><ul class="first last">
<li>’auto’: In this mode, all available methods will be tried in the following order: If a <cite>subjects_list</cite> is given, it is used. Then, the <cite>subjects_file</cite> is used if it exists. Note that this may be the default file, ‘$SUBJECTS_DIR/subject_surf_dir.txt’, or another if one has explicitely been defined by setting <cite>subjects_file</cite> and/or <cite>subjects_file_dir</cite>. If the file does not exist, the directory is searched for directories containing FreeSurfer data as defined in the section for ‘search_dir’ mode below. You can always see which method was used in auto mode by looking at the returned <cite>run_meta_data</cite>, see <cite>run_meta_data[‘subjects_detection_mode_auto_used_method’]</cite>.</li>
<li>’list’: In this mode, the given <cite>subjects_list</cite> is used, and you have to supply one. If not, an error is raised. You are not allowed to supply a <cite>subjects_file</cite> in this mode, or an error will be raised.</li>
<li>’file’: In this mode, the subjects file is used. Note that this may be the default file, ‘$SUBJECTS_DIR/subjects.txt’, or another if one has explicitely been defined by setting <cite>subjects_file</cite> and/or <cite>subjects_file_dir</cite>. If the file does not exist, an error is raised. You can see which file was used by looking at the returned <cite>run_meta_data</cite>, see <cite>run_meta_data[‘subjects_file’]</cite>. You are not allowed to supply a <cite>subjects_list</cite> in this mode, or an error will be raised.</li>
<li>’search_dir’: In this mode, the <cite>subjects_dir</cite> (default or explicitely given) is searched for sub directories which look as if they could contain FreeSurfer data. The latter means that they contain a sub directory named ‘surf’. There is one exception though: if the name of one such directory equals the name of the <cite>average_subject</cite>, the directory is skipped. You are not allowed to supply a <cite>subjects_list</cite> in this mode, or an error will be raised.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>group_morphometry_data</strong> (<em>numpy array</em>) – An array filled with the morphometry data for the subjects. The array has shape <cite>(n, m)</cite> where <cite>n</cite> is the number of subjects, and <cite>m</cite> is the number of vertices of the standard subject. (If you load both hemispheres instead of one, m doubles.) To get the subject id for the entries, look at the respective index in the returned <cite>subjects_list</cite>.</li>
<li><strong>subjects_list</strong> (<em>list of strings</em>) – A list containing the subject identifiers in the same order as the data in <cite>group_morphometry_data</cite>. (If <cite>subjects_detection_mode</cite> is ‘list’ or ‘file’, the order in these is guaranteed to be preserved. But in mode ‘search_dir’ or ‘auto’ which may have chosen to fall back to ‘search_dir’ as a last resort, this is helpful: You can use the index of a subject in this list to find its data in <cite>group_morphometry_data</cite>, as it will have the same index. See the examples below.)</li>
<li><strong>group_meta_data</strong> (<em>dictionary</em>) – A dictionary containing detailed information on all subjects and files that were loaded. Each of its keys is a subject identifier. The data value is another dictionary that contains all meta data for this subject as returned by the <cite>subject_avg</cite> function.</li>
<li><strong>run_meta_data</strong> (<em>dictionary</em>) – A dictionary containing general information on the settings used when executing the function and determining which subjects to load.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for all subjects in the directory defined by the environment variable SUBJECTS_DIR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">group_md</span><span class="p">,</span> <span class="n">run_md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;area&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we load curv data for the right hemisphere, computed on the pial surface with smooting of 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">group_md</span><span class="p">,</span> <span class="n">run_md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">surf</span><span class="o">=</span><span class="s1">&#39;pial&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;20&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We may want to be a but more explicit on which subjects are loaded from where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;subject4&#39;</span><span class="p">,</span> <span class="s1">&#39;subject8&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">subjects</span><span class="p">,</span> <span class="n">group_md</span><span class="p">,</span> <span class="n">run_md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;20&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">,</span> <span class="n">subjects_list</span><span class="o">=</span><span class="n">subjects_list</span><span class="p">)</span>
</pre></div>
</div>
<p>Continuing the last example, we may want to have a look at the curv value of the vertex at index 100000 of the subject ‘subject4’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subject4_idx</span> <span class="o">=</span> <span class="n">subjects</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;subject4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">data</span><span class="p">[</span><span class="n">subject4_idx</span><span class="p">][</span><span class="mi">100000</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.group_native">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">group_native</code><span class="sig-paren">(</span><em>measure</em>, <em>subjects_dir</em>, <em>subjects_list</em>, <em>surf='white'</em>, <em>hemi='both'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.group_native" title="Permalink to this definition">¶</a></dt>
<dd><p>Load native space morphometry data for a number of subjects.</p>
<p>Load native space group data, i.e., morphometry data for all subjects in a study.
The information given in the parameters <cite>measure</cite>, <cite>surf</cite>, and <cite>hemi</cite> are used to construct the file name that will be loaded by default. This function will NOT load the meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Data files for this measure have to exist for all subjects.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. Defaults to ‘white’. Will be added after the measure name unless left at default.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>subjects_list</strong> (list of strings, optional (unless <cite>subjects_detection_mode</cite> is set to <cite>list</cite>)) – A list of subject identifiers or directory names that should be loaded from the <cite>subjects_dir</cite>. Example list: <cite>[‘subject1’, ‘subject2’]</cite>. Defaults to None. Only allowed if <cite>subjects_detection_mode</cite> is <cite>auto</cite> or <cite>list</cite>. In <cite>auto</cite> mode, this takes
precedence over all other options, i.e., if a <cite>subjects_list</cite> <em>and</em> the (default or custom) <cite>subjects_file</cite> are given, the <cite>subjects_list</cite> will be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>morphdata_by_subject</strong> (<em>dictionary</em>) – A dictionary containing the morphometry data. Keys are subject identifiers, and values are the morphometry data numpy 1D arrays.</li>
<li><strong>group_meta_data</strong> (<em>dictionary</em>) – A dictionary containing detailed information on all subjects and files that were loaded. Each of its keys is a subject identifier. The data value is another dictionary that contains all meta data for this subject.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.hemi_range">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">hemi_range</code><span class="sig-paren">(</span><em>morphometry_meta_data</em>, <em>hemi</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.hemi_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute start and end index in the hemisphere data for the given hemisphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>morphometry_meta_data</strong> (dictionary as returned by the functions that read morphometry data (e.g., <code class="docutils literal notranslate"><span class="pre">`subject_data_native`</span></code>).) – </li>
<li><strong>hemi</strong> (<em>string</em><em>, </em><em>one of 'lh'</em><em> or </em><em>'rh'. The hemisphere you want to get the start and end index for.</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>start_index</strong> (<em>integer</em>) – The start index of the lh data.</li>
<li><strong>end_index</strong> (<em>integer</em>) – The end index of the lh data.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_data_native</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;/mnt/study1_data&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">hemi_range</span><span class="p">(</span><span class="n">meta_data</span><span class="p">,</span> <span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean lh thickness value is: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">morphometry_data</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">])))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.load_subject_mesh_files">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">load_subject_mesh_files</code><span class="sig-paren">(</span><em>lh_surf_file</em>, <em>rh_surf_file</em>, <em>hemi='both'</em>, <em>meta_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.load_subject_mesh_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Load mesh files for a subject.</p>
<p>Load one or two mesh files for a subject. Which of the two files <cite>lh_surf_file</cite> and <cite>rh_surf_file</cite> are actually loaded is determined by the <cite>hemi</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lh_surf_file</strong> (<em>string | None</em>) – A string representing an absolute path to a mesh file for the left hemisphere (e.g., the path to ‘lh.white’). If <cite>hemi</cite> is ‘rh’, this will be ignored and can thus be None.</li>
<li><strong>rh_surf_file</strong> (<em>string | None</em>) – A string representing an absolute path to a mesh file for the right hemisphere (e.g., the path to ‘rh.white’). If <cite>hemi</cite> is ‘lh’, this will be ignored and can thus be None.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere for which data should actually be loaded. Defaults to ‘both’.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array of floats</em>) – A 2D array containing 3 coordinates for each vertex. Dimension is (n, 3) for n vertices. If the argument <cite>hemi</cite> was ‘both’, this includes vertices from several meshes. You can check the <cite>meta_data</cite> return values to get the border between meshes, see <cite>meta_data[‘lh.num_vertices’]</cite> and  <cite>meta_data[‘rh.num_vertices’]</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array of integers</em>) – A 2D array containing 3 vertex indices per face. Dimension is (m, 3) for m faces. Look at the respective indices in <cite>vert_coords</cite> to get the vertex coordinates. If the argument <cite>hemi</cite> was ‘both’, this includes faces from several meshes. You can check the <cite>meta_data</cite> return values to get the border between meshes, see <cite>meta_data[‘lh.num_faces’]</cite> and  <cite>meta_data[‘rh.num_faces’]</cite>.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?h.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lh_surf_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;my_subjects_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="s1">&#39;lh.white&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rh_surf_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;my_subjects_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="s1">&#39;rh.white&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vert_coords</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">load_subject_mesh_files</span><span class="p">(</span><span class="n">lh_surf_file</span><span class="p">,</span> <span class="n">rh_surf_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.load_subject_morphometry_data_files">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">load_subject_morphometry_data_files</code><span class="sig-paren">(</span><em>lh_morphometry_data_file</em>, <em>rh_morphometry_data_file</em>, <em>hemi='both'</em>, <em>format='curv'</em>, <em>meta_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.load_subject_morphometry_data_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Load morphometry data files for a subject.</p>
<p>Load one or two morphometry data files for a subject. Which of the two files <cite>lh_morphometry_data_file</cite> and <cite>rh_morphometry_data_file</cite> are actually loaded is determined by the <cite>hemi</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lh_morphometry_data_file</strong> (<em>string | None</em>) – A string representing an absolute path to a morphometry data file for the left hemisphere. If <cite>hemi</cite> is ‘rh’, this will be ignored and can thus be None.</li>
<li><strong>rh_morphometry_data_file</strong> (<em>string | None</em>) – A string representing an absolute path to a morphometry data file for the right hemisphere. If <cite>hemi</cite> is ‘lh’, this will be ignored and can thus be None.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere for which data should actually be loaded. Defaults to ‘both’.</li>
<li><strong>format</strong> (<em>{'curv'</em><em>, </em><em>'mgh'}</em><em>, </em><em>optional</em>) – The file format for the files that are to be loaded. Defaults to ‘curv’.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – An array containing the scalar per-vertex data loaded from the file(s).</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load the lh and rh area files for subject1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lh_morphometry_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="s1">&#39;subjects_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="s1">&#39;lh.area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rh_morphometry_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="s1">&#39;subjects_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="s1">&#39;rh.area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">load_subject_morphometry_data_files</span><span class="p">(</span><span class="n">lh_morphometry_file</span><span class="p">,</span> <span class="n">rh_morphometry_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s look at the area value for the vertex at index 10:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;lh value at index 10: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">morphometry_data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>But what about the value of vertex 10 at the right hemisphere? We loaded 2 hemispheres, so the data is concatinated. But you can use the <cite>meta_data</cite> to get the correct index relative to the right hemisphere:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;rh value at index 10: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">morphometry_data</span><span class="p">[</span><span class="n">fsd</span><span class="o">.</span><span class="n">rhi</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">)]</span>
</pre></div>
</div>
<p>You could also get the value directly using the <cite>rhv</cite> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;rh value at index 10: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">fsd</span><span class="o">.</span><span class="n">rhv</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.merge_morphometry_data">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">merge_morphometry_data</code><span class="sig-paren">(</span><em>morphometry_data_arrays</em>, <em>dtype=&lt;class 'float'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.merge_morphometry_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge morphometry data horizontally.</p>
<p>Merge morphometry data read from several meshes of the same subject horizontally. This is used to merge data from the left and right hemispheres.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>morphometry_data_arrays</strong> (<em>2D array</em>) – An array of arrays, each of which represents morphometry data from different hemispheres of the same subject.</li>
<li><strong>dtype</strong> (<em>data type</em><em>, </em><em>optional</em>) – Data type for the output numpy array. Defaults to float.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Horizontally stacked array containing the data from all arrays in the input array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Merge some data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lh_morphometry_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>   <span class="c1"># some fake data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rh_morphometry_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merged_data</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">merge_morphometry_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lh_morphometry_data</span><span class="p">,</span> <span class="n">rh_morphometry_data</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">merged_data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, )</span>
</pre></div>
</div>
<p>Typically, the <cite>lh_morphometry_data</cite> and <cite>rh_morphometry_data</cite> come from calls to <cite>read_fs_morphometry_data_file_and_record_meta_data</cite> as shown here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lh_morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">read_fs_morphometry_data_file_and_record_meta_data</span><span class="p">(</span><span class="n">lh_morphometry_data_file</span><span class="p">,</span> <span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rh_morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">read_fs_morphometry_data_file_and_record_meta_data</span><span class="p">(</span><span class="n">rh_morphometry_data_file</span><span class="p">,</span> <span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">meta_data</span><span class="o">=</span><span class="n">meta_data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">both_hemis_morphometry_data</span> <span class="o">=</span> <span class="n">merge_morphometry_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lh_morphometry_data</span><span class="p">,</span> <span class="n">rh_morphometry_data</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.parse_talairach_file">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">parse_talairach_file</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.parse_talairach_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a talairach matrix from a talairach.xfm file.</p>
<p>Parse a talairach matrix from the mri/transforms/talairach.xfm file of a subject. Talairach space is a RAS space with the coordinate center at the Anterior Commisure. RAS (Right-Anterior-Superior) means X points to the right (from subjects point of view), Y points up out of the nose (subject is lying in scanner), and Z points out of the top of the head (so the axis is parallel to the floor). From the Freeurfer Wiki on coordinate systems: ‘Note on Talairach: FreeSurfer does not report true “Talairach” coordinates. The coordinates listed unter “Talairach” are actually based on Matthew Brett’s 10/8/98 non-linear transform from MNI305 space (see <a class="reference external" href="http://www.mrc-cbu.cam.ac.uk/Imaging/mnispace.html">http://www.mrc-cbu.cam.ac.uk/Imaging/mnispace.html</a>). FreeSurfer also reports “Talairach MNI” coordinates. These are MNI305 space.’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_name</strong> (<em>str</em>) – Path to the file, usually SUBJECT/mri/transforms/talairach.xfm</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The matrix, a float array with shape (3, 4).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 2D array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.read_fs_morphometry_data_file_and_record_meta_data">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">read_fs_morphometry_data_file_and_record_meta_data</code><span class="sig-paren">(</span><em>curv_file</em>, <em>hemisphere_label</em>, <em>meta_data=None</em>, <em>format='curv'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.read_fs_morphometry_data_file_and_record_meta_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a morphometry file and record meta data on it.</p>
<p>Read a morphometry file and record meta data on it. A morphometry file is file containing a scalar value for each vertex on the surface of a FreeSurfer mesh. An example is the file ‘lh.area’, which contains the area values for all vertices of the left hemisphere of the white surface. Such a file can be in two different formats: ‘curv’ or ‘mgh’. The former is used when the data refers to the surface mesh of the original subject, the latter when it has been mapped to a standard subject like fsaverage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>curv_file</strong> (<em>string</em>) – A string representing a path to a morphometry file (e.g., the path to ‘lh.area’).</li>
<li><strong>hemisphere_label</strong> (<em>{'lh'</em><em> or </em><em>'rh'}</em>) – A string representing the hemisphere this file belongs to. This is used to write the correct meta data.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
<li><strong>format</strong> (<em>{'curv'</em><em>, </em><em>'mgh'}</em><em>, </em><em>optional</em>) – The file format for the files that are to be loaded. Defaults to ‘curv’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>per_vertex_data</strong> (<em>numpy array</em>) – A 1D array containing one scalar value per vertex.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>curv_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lh_morphometry_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;my_subjects_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="s1">&#39;lh.area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lh_morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">read_fs_morphometry_data_file_and_record_meta_data</span><span class="p">(</span><span class="n">lh_morphometry_file</span><span class="p">,</span> <span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.num_data_points&#39;</span><span class="p">]</span>
<span class="go">121567                  # arbitrary number, depends on the subject mesh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.morphometry_file&#39;</span><span class="p">]</span>
<span class="go">my_subjects_dir/subject1/surf/lh.area             # on UNIX-like systems</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.read_fs_surface_file_and_record_meta_data">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">read_fs_surface_file_and_record_meta_data</code><span class="sig-paren">(</span><em>surf_file</em>, <em>hemisphere_label</em>, <em>meta_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.read_fs_surface_file_and_record_meta_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a surface file and record meta data on it.</p>
<p>Read a surface file and record meta data on it. A surface file is a mesh file in FreeSurfer format, e.g., ‘lh.white’. It contains vertices and 3-faces made out of them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surf_file</strong> (<em>string</em>) – A string representing an absolute path to a surface (or ‘mesh’) file (e.g., the path to ‘lh.white’).</li>
<li><strong>hemisphere_label</strong> (<em>{'lh'</em><em> or </em><em>'rh'}</em>) – A string representing the hemisphere this file belongs to. This is used to write the correct meta data.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2D array containing 3 coordinates for each vertex in the <cite>surf_file</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2D array containing 3 vertex indices per face. Look at the respective indices in <cite>vert_coords</cite> to get the vertex coordinates.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : value of the <cite>surf_file</cite> argument: the mesh file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vert_coords</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">read_fs_surface_file_and_record_meta_data</span><span class="p">(</span><span class="n">surf_file</span><span class="p">,</span> <span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.num_vertices&#39;</span><span class="p">]</span>
<span class="go">121567                  # arbitrary number, depends on the subject mesh</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.read_lookup_file">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">read_lookup_file</code><span class="sig-paren">(</span><em>lookup_file</em>, <em>dtype='&lt;U50'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.read_lookup_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a FreeSurfer lookup table file in text format.</p>
<p>Read a FreeSurfer lookup table file in text format, this is used for the FreeSurferColorLUT.txt file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lookup_file</strong> (<em>str</em>) – Path to the FreeSurferColorLUT.txt file. It comes with FreeSurfer and can be found directly in $FREESURFER_HOME for v6.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Array with shape (n, 6) for a file with n relevant lines. A relevant line is a line describing a segmentation in 6 fields (seg_code, structure_name, color_red, color_green, color_blue, color_alpha). There are 2 types of ignored lines in the file: empty lines and those starting with the comment character ‘#’. All other lines are considered relevant and split into the 6 parts.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 2D str array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.read_m3z_file">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">read_m3z_file</code><span class="sig-paren">(</span><em>m3z_file</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.read_m3z_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file in FreeSurfer m3z format.</p>
<p>Read a file in FreeSurfer m3z format, usually mri/transforms/talairach.m3z of a subject. An m3z file is a gzipped binary file containing a dense vector field that describes a 3D registration between two volumes/images. This implementation follows the Matlab implementation from the FreeSurfer source repository at github, see <a class="reference external" href="https://github.com/freesurfer/freesurfer/blob/dev/matlab/mris_read_m3z.m">https://github.com/freesurfer/freesurfer/blob/dev/matlab/mris_read_m3z.m</a>. This function is released under the Freesurfer license: <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense">https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m3z_file</strong> (<em>str</em>) – Path to a file in m3z format</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul>
<li><strong>vol_orig</strong> (<em>numpy 4D array</em>) – Array of np.single, containing 3 numbers per voxel. The shape is (width, height, depth, 3), where width, height, and depth are the dimensions of the source volume.</li>
<li><strong>vol_dest</strong> (<em>numpy 4D array</em>) – Array of np.single, containing 3 numbers per voxel. The shape is (width, height, depth, 3), where width, height, and depth are the dimensions of the destination volume.</li>
<li><strong>vol_ind0</strong> (<em>numpy 4D array</em>) – Array of np.int32, containing 3 numbers per voxel. The shape is (width, height, depth, 3).</li>
<li><strong>meta_data</strong> (<em>dictionary</em>) –<dl class="docutils">
<dt>Contains meta data on the registration. The following keys are included:</dt>
<dd><ul class="first last simple">
<li>version: float, File format version</li>
<li>width: int, Volume width</li>
<li>height: int, Volume height</li>
<li>depth: int, Volume depth</li>
<li>spacing: int, voxel spacing of the volume</li>
<li>exp_k: float, exp_k of the volume</li>
</ul>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Read a talairach.m3z file that has been generated by FreeSurfer’s <code class="docutils literal notranslate"><span class="pre">`recon-all`</span></code> command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m3z_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;my_study_data&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;mri&#39;</span><span class="p">,</span> <span class="s1">&#39;transforms&#39;</span><span class="p">,</span> <span class="s1">&#39;talairach.m3z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vol_orig</span><span class="p">,</span> <span class="n">vol_dest</span><span class="p">,</span> <span class="n">vol_ind0</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">read_m3z_file</span><span class="p">(</span><span class="n">m3z_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.read_mgh_file">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">read_mgh_file</code><span class="sig-paren">(</span><em>mgh_file_name</em>, <em>collect_meta_data=True</em>, <em>collect_data=True</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.read_mgh_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from a FreeSurfer output file in mgh format.</p>
<p>Read all data from the MGH file and return it as a numpy array. Optionally, collect meta data from the mgh file header.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mgh_file_name</strong> (<em>string</em>) – A string representing a full path to a file in FreeSurfer MGH file format. If the file name end with ‘.mgz’ or ‘.mgh.gz’, the file is assumed to be in gzipped MGH format.</li>
<li><strong>collect_meta_data</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to collect meta data from the MGH file header. Defaults to True.</li>
<li><strong>collect_data</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to collect the file data (voxel values) from the MGH file. Defaults to True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>mgh_data</strong> (<em>numpy array</em>) – The data from the MGH file, usually one scalar value per voxel.</li>
<li><strong>mgh_meta_data</strong> (<em>dictionary</em>) – The meta data collected from the header, or an empty dictionary if the argument <cite>collect_meta_data</cite> was ‘False’. The keys correspond to the names of the respective nibabel function used to retrieve the data. The values are the data as returned by nibabel.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Read a file in MGH format from the surf dir of a subject:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mgh_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;my_subjects_dir&#39;</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;surf&#39;</span><span class="p">,</span> <span class="s1">&#39;rh.area.fsaverage.mgh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mgh_data</span><span class="p">,</span> <span class="n">mgh_meta_data</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">read_mgh_file</span><span class="p">(</span><span class="n">mgh_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.read_mgh_header_matrices">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">read_mgh_header_matrices</code><span class="sig-paren">(</span><em>mgh_file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.read_mgh_header_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the 3 affine transformation matrices from a MGH file header.</p>
<p>Read the 3 affine transformation matrices ras2vox, vox2ras, and vox2ras_tkr from a MGH file header. The input file is assumed to be gzipped (and extracted appropriately) if the file name ends with ‘.mgz’ or ‘.mgh.gz’. See the FreeSurfer wiki on coordinate systems for details on what these matrices are. In short, RAS coordinates are used to specify positions of vertices in FreeSurfer surface files.</p>
<p>In short, VOX is the voxel index and the RAS coordinate is used for the surface coordinate of a vertex.</p>
<p>VOX: After FreeSurfer pre-processing, this is a triplet of integers in range 0 - 255 for 3D images. Note though that the original T1 images (before pre-processing) from a study can - and usually will - have different numbers of voxels (both different between the axes of a single image as well as between subjects). The VOX is sometimes called CRS for voxel column, row, slice.</p>
<p>RAS: Right-Anterior-Superior (anatomical coordinates). According to <a class="reference external" href="http://www.grahamwideman.com/gw/brain/fs/coords/fscoords.htm">http://www.grahamwideman.com/gw/brain/fs/coords/fscoords.htm</a>, the RAS coordinate origin (0, 0, 0) is the center of the voxel (128, 128, 128). Note that this voxel could or could NOT be the center of the MRI volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mgh_file_name</strong> (<em>string</em>) – Path to a file in MGH format. The input file is assumed to be gzipped (and extracted appropriately) if the file name ends with ‘.mgz’ or ‘.mgh.gz’.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>ras2vox</strong> (<em>numpy array</em>) – 2D numpy array with shape (4, 4). Transformation matrix from RAS coordinate to voxel index.</li>
<li><strong>vox2ras</strong> (<em>numpy array</em>) – 2D numpy array with shape (4, 4). Transformation matrix from voxel index to RAS coordinate.</li>
<li><strong>vox2ras_tkr</strong> (<em>numpy array</em>) – 2D numpy array with shape (4, 4). Transformation matrix from voxel index to (tkregister) surface RAS coordinate. This is a RAS coordinate of a vertex on the surface.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">brainload.freesurferdata</span> <span class="k">as</span> <span class="nn">fsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mgh_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;mri&#39;</span><span class="p">,</span> <span class="s1">&#39;orig.mgh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ras2vox</span><span class="p">,</span> <span class="n">vox2ras</span><span class="p">,</span> <span class="n">vox2ras_tkr</span> <span class="o">=</span> <span class="n">fsd</span><span class="o">.</span><span class="n">read_mgh_header_matrices</span><span class="p">(</span><span class="n">mgh_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.rhi">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">rhi</code><span class="sig-paren">(</span><em>rh_relative_index</em>, <em>meta_data</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.rhi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the absolute data index given an index relative to the right hemisphere.</p>
<p>This function makes sense only given a <cite>morphometry_data</cite> and associated <cite>meta_data</cite> that contains data on two hemispheres (even though the <cite>morphometry_data</cite> array itself is not passed to this function). E.g., the return value of a function like <cite>subject()</cite> or <cite>subject_avg()</cite> when called with <cite>hemi=’both’</cite>. For such data, it computes the absolute index in the data given a request index relative to the right hemisphere. The name is short for ‘right hemisphere index’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rh_relative_index</strong> (<em>int</em>) – An index relative to the right hemisphere. E.g., <cite>0</cite> if you want to get the index of the first vertex of the right hemisphere. Its absolute value must be between 0 and the number of vertices of the right hemisphere. Negative values are allowed, and <cite>-1</cite> will get you the second-to-last possible index, <cite>-2</cite> the third-to-last, and so on.</li>
<li><strong>meta_data</strong> (<em>dictionary</em>) – The meta data dictionary returned for your data. It must contain the keys ‘lh.num_data_points’ and ‘rh.num_data_points’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The absolute index into the data for the given <cite>rh_relative_index</cite>.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;heinz&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;rh value at index 10, relative to start of right hemisphere: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">morphometry_data</span><span class="p">[</span><span class="n">bl</span><span class="o">.</span><span class="n">rhi</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.rhv">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">rhv</code><span class="sig-paren">(</span><em>rh_relative_index</em>, <em>morphometry_data</em>, <em>meta_data</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.rhv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value in <cite>morphometry_data</cite> at an index relative to the right hemisphere.</p>
<p>This function makes sense only given a <cite>morphometry_data</cite> and associated <cite>meta_data</cite> that contains data on two hemispheres. E.g., the return value of a function like <cite>subject()</cite> or <cite>subject_avg()</cite> when called with <cite>hemi=’both’</cite>. For such data, it returns the value in <cite>morphometry_data</cite> at a request index given relative to the right hemisphere. The name is short for ‘right hemisphere value’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rh_relative_index</strong> (<em>int</em>) – An index relative to the start of the right hemisphere in the data. E.g., <cite>0</cite> if you want to get the value for the first vertex of the right hemisphere. Its absolute value must be between 0 and the number of vertices of the right hemisphere. Negative values are allowed, and <cite>-1</cite> will get you the last possible value, <cite>-2</cite> the second-to-last, and so on.</li>
<li><strong>morphometry_data</strong> (<em>numpy array</em>) – The morphometry data array, must represent data for both hemispheres.</li>
<li><strong>meta_data</strong> (<em>dictionary</em>) – The meta data dictionary returned for your data. It must contain the keys ‘lh.num_data_points’ and ‘rh.num_data_points’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The value at the given index that is relative to the start of the right hemisphere in the data.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;heinz&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;rh value at index 10, relative to start of right hemisphere: </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">bl</span><span class="o">.</span><span class="n">rhv</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.subject">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">subject</code><span class="sig-paren">(</span><em>subject_id</em>, <em>surf='white'</em>, <em>measure='area'</em>, <em>hemi='both'</em>, <em>subjects_dir=None</em>, <em>meta_data=None</em>, <em>load_surface_files=True</em>, <em>load_morphometry_data=True</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.subject" title="Permalink to this definition">¶</a></dt>
<dd><p>Load FreeSurfer brain morphometry and/or mesh data for a single subject.</p>
<p>High-level interface to load FreeSurfer brain data for a single space. This parses the data for the surfaces of this subject. If you want to load data that has been mapped to an average subject like ‘fsaverage’, use <cite>subject_avg</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em><em>, </em><em>optional</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Defaults to ‘area’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>meta_data</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – A dictionary that should be merged into the return value <cite>meta_data</cite>. Defaults to the empty dictionary if omitted.</li>
<li><strong>load_surface_files</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load mesh data. If set to <cite>False</cite>, the first return values <cite>vert_coords</cite> and <cite>faces</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
<li><strong>load_morphometry_data</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load morphometry data. If set to <cite>False</cite>, the first return value <cite>morphometry_data</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. Note that the two hemispheres do in general NOT have the same number of vertices.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘subject’. This means that the data loaded represent morphometry data taken from the subject’s surface (as opposed to data mapped to a common or average subject).</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for both hemispheres and white surface of subject1 in the directory defined by the environment variable SUBJECTS_DIR:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we are a bit more explicit about what we want to load:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_home</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">user_home</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometimes we do not care for the mesh, e.g., we only want the morphometry data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">load_surface_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>…or the other way around (mesh only, no morphometry data):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">load_morphometry_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.subject_avg">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">subject_avg</code><span class="sig-paren">(</span><em>subject_id</em>, <em>measure='area'</em>, <em>surf='white'</em>, <em>display_surf='white'</em>, <em>hemi='both'</em>, <em>fwhm='10'</em>, <em>subjects_dir=None</em>, <em>average_subject='fsaverage'</em>, <em>subjects_dir_for_average_subject=None</em>, <em>meta_data=None</em>, <em>load_surface_files=True</em>, <em>load_morphometry_data=True</em>, <em>custom_morphometry_files=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.subject_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>Load morphometry data that has been mapped to an average subject for a subject, i.e., standard space data.</p>
<p>Load data for a single subject that has been mapped to an average subject like the <cite>fsaverage</cite> subject from FreeSurfer. Can also load the mesh of an arbitrary surface for the average subject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em><em>, </em><em>optional</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Defaults to ‘area’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>fwhm</strong> (<em>string</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Which averaging version of the data should be loaded. FreeSurfer usually generates different standard space files with a number of smoothing settings. Defaults to ‘10’. If None is passed, the <cite>.fwhmX</cite> part is omitted from the file name completely. Set this to ‘0’ to get the unsmoothed version.</li>
<li><strong>subjects_dir</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study. Defaults to the environment variable SUBJECTS_DIR if omitted. If that is not set, used the current working directory instead. This is the directory from which the application was executed.</li>
<li><strong>average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the average subject to which the data was mapped. Defaults to ‘fsaverage’.</li>
<li><strong>display_surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The surface of the average subject for which the mesh should be loaded, e.g., ‘white’, ‘pial’, ‘inflated’, or ‘sphere’. Defaults to ‘white’. Ignored if <cite>load_surface_files</cite> is <cite>False</cite>.</li>
<li><strong>subjects_dir_for_average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – A string representing the full path to a directory. This can be used if the average subject is not in the same directory as all your study subjects. Defaults to the setting of <cite>subjects_dir</cite>.</li>
<li><strong>meta_data</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – A dictionary that should be merged into the return value <cite>meta_data</cite>. Defaults to the empty dictionary if omitted.</li>
<li><strong>load_surface_files</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load mesh data. If set to <cite>False</cite>, the first return values <cite>vert_coords</cite> and <cite>faces</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
<li><strong>load_morphometry_data</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to load morphometry data. If set to <cite>False</cite>, the first return value <cite>morphometry_data</cite> will be <cite>None</cite>. Defaults to <cite>True</cite>.</li>
<li><strong>custom_morphometry_files</strong> (<em>dictionary</em><em>, </em><em>optional</em>) – Cutom filenames for the left and right hemispjere data files that should be loaded. A dictionary of strings with exactly the following two keys: <cite>lh</cite> and <cite>rh</cite>. The value strings must contain hardcoded file names or template strings for them. As always, the files will be loaded relative to the <cite>surf/</cite> directory of the respective subject. Example: <cite>{‘lh’: ‘lefthemi.nonstandard.mymeasure44.mgh’, ‘rh’: ‘righthemi.nonstandard.mymeasure44.mgh’}</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the average subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the average subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the average subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. In many cases, your average subject will have the same number of vertices for both hemispheres and you will know this number beforehand, so you may not have to worry about this at all.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘common’. This means that the data loaded represent morphometry data that has been mapped to a common or average subject.</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
<li><cite>display_subject</cite> : the name of the common or average subject. This is the subject the surface meshes originate from. Ususally ‘fsaverage’.</li>
<li><cite>display_surf</cite> : the surface of the common subject that has been loaded. Something like ‘pial’, ‘white’, or ‘inflated’.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load area data for both hemispheres and white surface of subject1 in the directory defined by the environment variable SUBJECTS_DIR, mapped to fsaverage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_avg</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;surf&#39;</span><span class="p">]</span>
<span class="go">white</span>
</pre></div>
</div>
<p>Here, we are a bit more picky and explicit about what we want to load:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_home</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">user_home</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_avg</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="s1">&#39;curv&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="n">display_surf</span><span class="o">=</span><span class="s1">&#39;inflated&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="o">=</span><span class="n">subjects_dir</span><span class="p">)</span>
</pre></div>
</div>
<p>Sometime we do not care for the mesh, e.g., we only want the morphometry data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">md</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_avg</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="n">load_surface_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.subject_data_native">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">subject_data_native</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>measure</em>, <em>hemi</em>, <em>surf='white'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.subject_data_native" title="Permalink to this definition">¶</a></dt>
<dd><p>Load native space morphometry data for a subject (e.g., lh.area).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’. Defaults to ‘area’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. For white, nothing will be added. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em>) – The hemisphere that should be loaded.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. Note that the two hemispheres do in general NOT have the same number of vertices.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘subject’. This means that the data loaded represent morphometry data taken from the subject’s surface (as opposed to data mapped to a common or average subject).</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">morphometry_data</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_data_native</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;/mnt/study1_data&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.subject_data_standard">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">subject_data_standard</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>measure</em>, <em>hemi</em>, <em>fwhm</em>, <em>average_subject='fsaverage'</em>, <em>surf='white'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.subject_data_standard" title="Permalink to this definition">¶</a></dt>
<dd><p>Load standard space data for a subject (e.g., lh.area.fwhm10.fsaverage.mgh).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject. As always, it is assumed that this is the name of the directory containing the subject’s data, relative to <cite>subjects_dir</cite>. Example: ‘subject33’.</li>
<li><strong>measure</strong> (<em>string</em>) – The measure to load, e.g., ‘area’ or ‘curv’.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em>) – The hemisphere that should be loaded.</li>
<li><strong>fwhm</strong> (<em>string</em><em> or </em><em>None</em>) – Which averaging version of the data should be loaded. FreeSurfer usually generates different standard space files with a number of smoothing settings. If None is passed, the <cite>.fwhmX</cite> part is omitted from the file name completely. Set this to ‘0’ to get the unsmoothed version.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study.</li>
<li><strong>average_subject</strong> (<em>string</em><em>, </em><em>optional</em>) – The name of the average subject to which the data was mapped. Defaults to ‘fsaverage’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>morphometry_data</strong> (<em>numpy array</em>) – A numpy array with as many entries as there are vertices in the subject. If you load two hemispheres instead of one, the length doubles. You can get the start indices for data of the hemispheres in the returned <cite>meta_data</cite>, see <cite>meta_data[‘lh.num_vertices’]</cite> and <cite>meta_data[‘rh.num_vertices’]</cite>. You can be sure that the data for the left hemisphere will always come first (if both were loaded). Indices start at 0, of course. So if the left hemisphere has <cite>n</cite> vertices, the data for them are at indices <cite>0..n-1</cite>, and the data for the right hemisphere start at index <cite>n</cite>. Note that the two hemispheres do in general NOT have the same number of vertices.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_data_points</cite> : the number of data points loaded.</li>
<li><cite>?h.morphometry_file</cite> : the value of the <cite>?h_morphometry_data_file</cite> argument (data file that was loaded)</li>
<li><cite>?h.morphometry_file_format</cite> : the value for <cite>format</cite> that was used</li>
<li><cite>subject_id</cite> : the subject id</li>
<li><cite>subjects_dir</cite> : the subjects dir that was used</li>
<li><cite>surf</cite> : the surf that was used, e.g., ‘white’</li>
<li><cite>measure</cite> : the measure that was loaded as morphometry data, e.g., ‘area’</li>
<li><cite>space</cite> : always the string ‘common’. This means that the data loaded represent morphometry data that has been mapped to a common or average subject.</li>
<li><cite>hemi</cite> : the <cite>hemi</cite> value that was used</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.freesurferdata.subject_mesh">
<code class="descclassname">brainload.freesurferdata.</code><code class="descname">subject_mesh</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>surf='white'</em>, <em>hemi='both'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.freesurferdata.subject_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a surface mesh of a subject.</p>
<p>Convenience function to load a FreeSurfer surface mesh of a subject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier of the subject.</li>
<li><strong>surf</strong> (<em>string</em><em>, </em><em>optional</em>) – The brain surface where the data has been measured, e.g., ‘white’ or ‘pial’. This will become part of the file name that is loaded. Defaults to ‘white’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere that should be loaded. Defaults to ‘both’.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the full path to a directory. This should be the directory containing all subjects of your study.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>vert_coords</strong> (<em>numpy array</em>) – A 2-dimensional array containing the vertices of the mesh(es) of the subject. Each vertex entry contains 3 coordinates. Each coordinate describes a 3D position in a FreeSurfer surface file (e.g., ‘lh.white’), as returned by the <cite>nibabel</cite> function <cite>nibabel.freesurfer.io.read_geometry</cite>.</p>
</li>
<li><p class="first"><strong>faces</strong> (<em>numpy array</em>) – A 2-dimensional array containing the 3-faces of the mesh(es) of the subject. Each face entry contains 3 indices. Each index references the respective vertex in the <cite>vert_coords</cite> array.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>A dictionary containing detailed information on all files that were loaded and used settings. The following keys are available (depending on the value of the <cite>hemi</cite> argument, you can replace ?h with ‘lh’ or ‘rh’ or both ‘lh’ and ‘rh’):</dt>
<dd><ul class="first last simple">
<li><cite>?h.num_vertices</cite> : number of vertices in the loaded mesh</li>
<li><cite>?h.num_faces</cite> : number of faces in the loaded mesh</li>
<li><cite>?lh.surf_file</cite> : the mesh file that was loaded for this hemisphere</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If one of the parameters with a fixed set of values receives a value that is not allowed.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load the pial surface mesh for both hemispheres of the Freeurfer example subject bert:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span><span class="o">,</span> <span class="nn">import</span> <span class="n">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;Applications&#39;</span><span class="p">,</span> <span class="s1">&#39;freesurfer&#39;</span><span class="p">,</span> <span class="s1">&#39;subjects&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faced</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject_mesh</span><span class="p">(</span><span class="s1">&#39;bert&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="n">surf</span><span class="o">=</span><span class="s1">&#39;pial&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-brainload.annotations">
<span id="brainload-annotations-module"></span><h2>brainload.annotations module<a class="headerlink" href="#module-brainload.annotations" title="Permalink to this headline">¶</a></h2>
<p>Read FreeSurfer vertex label and annotation files.</p>
<p>Functions for reading FreeSurfer vertex annotation files. These are the file in the label sub directory of a subject, with file extensions ‘.label’ and ‘.annot’. Examples are ‘lh.aparc.annot’ and ‘lh.cortex.label’. A label is a set of vertices. An annotation consists of several sets of vertices, each of which is assigned a label and a color.</p>
<dl class="class">
<dt id="brainload.annotations.AnnotQuery">
<em class="property">class </em><code class="descclassname">brainload.annotations.</code><code class="descname">AnnotQuery</code><span class="sig-paren">(</span><em>vertex_lookup_indices</em>, <em>label_colors</em>, <em>label_names</em>, <em>name_dtype='U50'</em>, <em>name_null_value='None'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.AnnotQuery" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Convenience class that allows one to query the vertex names and colors for a list of vertex indices. The required parameters for the constructor are what is returned by the annot</p>
<dl class="method">
<dt id="brainload.annotations.AnnotQuery.compute_labels">
<code class="descname">compute_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.AnnotQuery.compute_labels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brainload.annotations.AnnotQuery.get_vertex_label_colors">
<code class="descname">get_vertex_label_colors</code><span class="sig-paren">(</span><em>query_vertex_indices</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.AnnotQuery.get_vertex_label_colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the label color for a list of vertex indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_vertex_indices</strong> (<em>numpy 1D int array</em>) – The vertex indices (in the mesh) for which you want to query the color.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Color array with shape (n, 4) for n query vertices. Each color is represented by 4 int values that encode an RGBT color, where T is transparency and equal to T = alpha - 255.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 2D int array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.annotations.AnnotQuery.get_vertex_label_names">
<code class="descname">get_vertex_label_names</code><span class="sig-paren">(</span><em>query_vertex_indices</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.AnnotQuery.get_vertex_label_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the label name for a list of vertex indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_vertex_indices</strong> (<em>numpy 1D int array</em>) – The vertex indices (in the mesh) for which you want to query the name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Name array with shape (n, ) for n query vertices.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 1D string array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="brainload.annotations.annot">
<code class="descclassname">brainload.annotations.</code><code class="descname">annot</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>annotation</em>, <em>hemi='both'</em>, <em>meta_data=None</em>, <em>orig_ids=False</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.annot" title="Permalink to this definition">¶</a></dt>
<dd><p>Load annotation for the mesh vertices of a single subject.</p>
<p>An annotation defines a label string and a color to each vertex, it is typically used to define brain regions, e.g., for cortical parcellation. An annotation consists of several groups of vertices, each of which is assigned a label and a color.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier.</li>
<li><strong>subject_dir</strong> (<em>string</em>) – A string representing the path to the subjects dir.</li>
<li><strong>annotation</strong> (<em>string</em>) – An annotation to load, part of the file name of the respective file in the subjects label directory. E.g., ‘aparc’, ‘aparc.a2009s’, or ‘aparc.DKTatlas’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere for which data should actually be loaded. Defaults to ‘both’.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
<li><strong>orig_ids</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Passed on to nibabel.freesurfer.io.read_annot function. From the documentation of that function: ‘Whether to return the vertex ids as stored in the annotation file or the positional colortable ids. With orig_ids=False vertices with no id have an id set to -1.’ Defaults to False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>vertex_labels</strong> (<em>ndarray, shape (n_vertices,)</em>) – If orig_ids is False (the default), returns the index (for each vertex) into the label_colors and label_names datastructures to retrieve the color and name. If some vertex has no annotation, -1 is returned for it.</p>
<p>If orig_ids is True, returns an annotation color id for each vertex listed in the annotation file. IMPORTANT: The annotation value in here is NOT the label id. It is a code based on the color for the vertex. Yes, this is ugly. See <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles#Annotation">https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles#Annotation</a> for details, especially the section ‘Annotation file design surprise’. The color is encoded as a single number. Quoting the linked document, the numer is the ‘RGB value combined into a single 32-bit integer: annotation value = (B * 256^2) + (G * 256) + (R)’. From this it follows that, quoting the doc once more, ‘Code that loads an annotation file … has to compare annotation values to the color values in the ColorLUT part of the annotation file to discover what parcellation label code (ie: structure code) corresponds.’ (Basically this has already been done for you if you simply set orig_ids to False.)</p>
</li>
<li><p class="first"><strong>label_colors</strong> (<em>ndarray, shape (n_labels, 5)</em>) – RGBT + label id colortable array. The first 4 values encode the label color: RGB is red, green, blue as usual, from 0 to 255 per value. T is the transparency, which is defined as 255 - alpha. The last value represents the label id. The number of labels (n_label) cannot be know in advance by this function in the general case (but the user can know based on the Atlas he is loading, e.g., the Desikan-Killiany Atlas has 36 labels).</p>
</li>
<li><p class="first"><strong>label_names</strong> (<em>list of strings</em>) – The names of the labels. The length of the list is n_labels. Note that, contrary to the respective nibabel function, this function will always return this as a list of strings, no matter the Python version used.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.annotation_file</cite> : the file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load cortical parcellation annotations for both hemispheres of a subject from the Desikan-Killiany (‘aparc’) atlas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_labels</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">,</span> <span class="n">label_names</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">annot</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;aparc&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.aparc.annot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;rh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/rh.aparc.annot</span>
</pre></div>
</div>
<p>Now load cortical parcellation annotations for the left hemisphere of a subject from the Destrieux (‘aparc.a2009s’) atlas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_labels</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">,</span> <span class="n">label_names</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">annot</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;aparc.a2009s&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.aparc.a2009s.annot</span>
</pre></div>
</div>
<p>Now load cortical parcellation annotations for the right hemisphere of a subject from the DKT (‘aparc.DKTatlas40’) atlas:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_labels</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">,</span> <span class="n">label_names</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">annot</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;aparc.DKTatlas40&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;rh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;rh.annotation_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.aparc.DKTatlas40.annot</span>
</pre></div>
</div>
<p>Print the color and the annotation name for an example vertex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vert_idx</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c1"># We&#39;ll take the first vertex as an example.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">vertex_labels</span><span class="p">[</span><span class="n">vert_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>     <span class="c1"># it is -1 if the vertex is not assigned any label/color</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">i</span> <span class="o">=</span> <span class="n">vertex_labels</span><span class="p">[</span><span class="n">vert_idx</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span> <span class="s2">&quot;label for vertex </span><span class="si">%d</span><span class="s2"> is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vert_idx</span><span class="p">,</span> <span class="n">label_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span> <span class="s2">&quot;color for vertex </span><span class="si">%d</span><span class="s2"> in RGBA is (</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vert_idx</span><span class="p">,</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="n">label_colors</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>Atlas information is available at <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation">https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation</a></p>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.color_rgbt_to_rgba">
<code class="descclassname">brainload.annotations.</code><code class="descname">color_rgbt_to_rgba</code><span class="sig-paren">(</span><em>rgbt</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.color_rgbt_to_rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert RGBT color to RGBA.</p>
<p>Convert an RGBT color given as (r, g, b, t) with all values in range [0.255] to the respective color in RGBA. The T is for transparency, an defined as 1 - alpha, where alpha is the RGBA value A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rgbt</strong> (<em>tupel of 4 integers</em><em> (</em><em>in range 0..255</em><em>)</em>) – The color according to RGBT definition, where T is transparency.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The color in RGBA notation.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tupel of 4 integers (in range 0..255)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Convert a color from RGBT to RGBA:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.annotations</span> <span class="k">as</span> <span class="nn">an</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">an</span><span class="o">.</span><span class="n">color_rgbt_to_rgba</span><span class="p">((</span><span class="mi">120</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="go">(120, 0, 240, 215)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.get_atlas_region_names">
<code class="descclassname">brainload.annotations.</code><code class="descname">get_atlas_region_names</code><span class="sig-paren">(</span><em>annotation</em>, <em>subjects_dir</em>, <em>subject_id='fsaverage'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.get_atlas_region_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the region names of the label for an annotation from the annot file of a subject.</p>
<p>Get the region names of the label for an annotation from the annot file of a subject. It’s best to get them from fsaverage in subjects_dir FREESURFER_HOME/subjects/. Gettings them from stats files (which this function does NOT do), is not recommended, as they only contain regions with &gt;0 vertices assigned to them for each subject, so you may miss regions.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.get_atlas_region_names_hardcoded">
<code class="descclassname">brainload.annotations.</code><code class="descname">get_atlas_region_names_hardcoded</code><span class="sig-paren">(</span><em>atlas</em>, <em>freesurfer_version=6</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.get_atlas_region_names_hardcoded" title="Permalink to this definition">¶</a></dt>
<dd><p>The region names for the stats files, Freesurfer v6.</p>
<p>Return atlas region names for the stats files, Freesurfer v6. If no hardcoded list exists for the requested atlas, return None. WARNING: These were derived from one subject, and may miss some regions. We still need to verify that these are all possible regions.
Also note that the names changed in FreeSurfer 6: all regions names which include an ampersand (‘&amp;’) have changed since 5.x. Formlery, the string ‘and’ was used, it has now been replaces with ‘&amp;’. So the label ‘G&amp;S_frontomargin’ was called ‘GandS_frontomargin’ if the data you are reading originates from an older FreeSurfer version.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>atlas</strong> (<em>string</em>) – A parcellation or segmentation name. One of ‘aseg’, ‘aparc’, ‘aparc.a2009s’, ‘aparc.DKTatlas’.</li>
<li><strong>freesurfer_version</strong> (<em>int</em><em>, </em><em>one of 5</em><em> or </em><em>6.</em>) – The FreeSurfer version for which the names should fit. See the function description for details. Defaults to 6.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The hardcoded region names, or None if none are hardcoded for the given atlas.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.label">
<code class="descclassname">brainload.annotations.</code><code class="descname">label</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>label</em>, <em>hemi='both'</em>, <em>meta_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Load annotation for the mesh vertices of a single subject.</p>
<p>An annotation defines a label string and a color to each vertex, it is typically used to define brain regions, e.g., for cortical parcellation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier.</li>
<li><strong>subject_dir</strong> (<em>string</em>) – A string representing the path to the subjects dir.</li>
<li><strong>label</strong> (<em>string</em>) – A label to load, part of the file name of the respective file in the subjects label directory. E.g., ‘cortex’.</li>
<li><strong>hemi</strong> (<em>{'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em><em>, </em><em>optional</em>) – The hemisphere for which data should actually be loaded. Defaults to ‘both’.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional if hemi is 'lh'</em><em> or </em><em>'rh'</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary. If ‘hemi’ is ‘both’, this dictionary is required and MUST contain at least one of the keys ‘lh.num_vertices’ or ‘lh.num_data_points’, the value of which must contain the number of vertices of the left hemisphere of the subject. Background: If hemi is ‘both’, the vertex indices of both hemispheres are merged in the return value verts_in_label, and thus we need to know the shift, i.e., the number of vertices in the left hemisphere.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>verts_in_label</strong> (<em>ndarray, shape (n_vertices,)</em>) – Contains the ids of all vertices included in the label.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.label_file</cite> : the file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load the cortex label for the left hemisphere of a subject:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts_in_label</span><span class="p">,</span> <span class="n">meta_data</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="s1">&#39;cortex&#39;</span><span class="p">,</span> <span class="n">hemi</span><span class="o">=</span><span class="s1">&#39;lh&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;lh.label_file&#39;</span><span class="p">]</span>     <span class="c1"># will print /home/someuser/data/my_study_x/subject1/label/lh.cortex.label</span>
</pre></div>
</div>
<p>You could now use the label information to mask your morphology data.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#brainload.annotations.mask_data_using_label" title="brainload.annotations.mask_data_using_label"><code class="xref py py-func docutils literal notranslate"><span class="pre">mask_data_using_label()</span></code></a></dt>
<dd>Mask data using a label.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.label_to_mask">
<code class="descclassname">brainload.annotations.</code><code class="descname">label_to_mask</code><span class="sig-paren">(</span><em>verts_in_label</em>, <em>num_verts_total</em>, <em>invert=False</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.label_to_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate binary mask from vertex indices.</p>
<p>Generate a binary mask from the list of vertex indices in verts_in_label. The mask contains one entry for each vertex, i.e., it has length num_verts_total.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>verts_in_label</strong> (<em>1D numpy array</em>) – Array of vertex indices.</li>
<li><strong>num_verts_total</strong> (<em>int</em>) – The total number of vertices that exist. (Obviously, the highest index in verts_in_label does not need to be the last vertex.)</li>
<li><strong>invert</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether the mask should be inverted. If inverse is set to False (or not set at all), vertex indices which occur in verts_in_label will be set to True in the mask. If inverse is set to True, vertex indices which occur in the mask will be set to False in the mask instead.  Defaults to False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mask</strong> – The mask array, length is num_verts_total.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array of booleans</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#brainload.annotations.mask_data_using_label" title="brainload.annotations.mask_data_using_label"><code class="xref py py-func docutils literal notranslate"><span class="pre">mask_data_using_label()</span></code></a></dt>
<dd>Mask data using a label.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.mask_data_using_label">
<code class="descclassname">brainload.annotations.</code><code class="descname">mask_data_using_label</code><span class="sig-paren">(</span><em>data</em>, <em>verts_in_label</em>, <em>invert=False</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.mask_data_using_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask data using a list of vertex indices.</p>
<p>Set all indices in data which do NOT occur in verts_in_label to np.nan. If invert is True, set all indices which DO occur in verts_in_label to np.nan. In both cases, the other values are not altered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>numpy array</em>) – Array of input data.</li>
<li><strong>verts_in_label</strong> (<em>numpy array of int</em>) – Each number in the array represents a vertex index in the data array.</li>
<li><strong>invert</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether the mask should be inverted. If inverse is set to False (default), vertex indices which occur in verts_in_label will be left unaltered, and all others will be set to np.nan. If inverse is set to True, the opposite happens. Defaults to False.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional if hemi is 'lh'</em><em> or </em><em>'rh'</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary. If ‘hemi’ is ‘both’, this dictionary is required and MUST contain at least one of the keys ‘lh.num_vertices’ or ‘lh.num_data_points’, the value of which must contain the number of vertices of the left hemisphere of the subject. Background: If hemi is ‘both’, the vertex indices of both hemispheres are merged in the return value verts_in_label, and thus we need to know the shift, i.e., the number of vertices in the left hemisphere.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The masked data. (This is a copy, the input data is not altered.)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array of booleans</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.read_annotation_md">
<code class="descclassname">brainload.annotations.</code><code class="descname">read_annotation_md</code><span class="sig-paren">(</span><em>annotation_file</em>, <em>hemisphere_label</em>, <em>meta_data=None</em>, <em>encoding='utf-8'</em>, <em>orig_ids=False</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.read_annotation_md" title="Permalink to this definition">¶</a></dt>
<dd><p>Read annotation file and record meta data for it.</p>
<p>For details on the first three return values, see <a class="reference external" href="http://nipy.org/nibabel/reference/nibabel.freesurfer.html#nibabel.freesurfer.io.read_annot">http://nipy.org/nibabel/reference/nibabel.freesurfer.html#nibabel.freesurfer.io.read_annot</a> as they are the output of that function. An exception is the last parameter (names, names_str in this function) which returns a different data type depending on the Python version for the nibabel function. This function always returns strings, independent of the Python version.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>annotation_file</strong> (<em>string</em>) – A string representing a path to a FreeSurfer vertex annotation file (e.g., the path to ‘lh.aparc.annot’).</li>
<li><strong>hemisphere_label</strong> (<em>{'lh'</em><em> or </em><em>'rh'}</em>) – A string representing the hemisphere this file belongs to. This is used to write the correct meta data.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
<li><strong>encoding</strong> (<em>string describing an encoding</em><em>, </em><em>optional</em>) – The encoding to use when decoding the label strings from binary. Only used in Python 3. Defaults to ‘utf-8’.</li>
<li><strong>orig_ids</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Passed on to nibabel.freesurfer.io.read_annot function. From the documentation of that function: ‘Whether to return the vertex ids as stored in the annotation file or the positional colortable ids. With orig_ids=False vertices with no id have an id set to -1.’ Defaults to False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>vertex_label_colors</strong> (<em>ndarray, shape (n_vertices,)</em>) – Contains an annotation color id for each vertex listed in the annotation file. If orig_ids is False (the default), and some vertex has no annotation, -1 is returned for it. IMPORTANT: The annotation value in here is NOT the label id. It is the color for the vertex, encoded in a weird way! Yes, this is ugly. See <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles#Annotation">https://surfer.nmr.mgh.harvard.edu/fswiki/LabelsClutsAnnotationFiles#Annotation</a> for details, especially the section ‘Annotation file design surprise’. The color is encoded as a single number. Quoting the linked document, the numer is the ‘RGB value combined into a single 32-bit integer: annotation value = (B * 256^2) + (G * 256) + (R)’. From this it follows that, quoting the doc once more, ‘Code that loads an annotation file … has to compare annotation values to the color values in the ColorLUT part of the annotation file to discover what parcellation label code (ie: structure code) corresponds.’</p>
</li>
<li><p class="first"><strong>label_colors</strong> (<em>ndarray, shape (n_labels, 5)</em>) – RGBT + label id colortable array. The first 4 values encode the label color: RGB is red, green, blue as usual, from 0 to 255 per value. T is the transparency, which is defined as 255 - alpha. The number of labels (n_label) cannot be know in advance.</p>
</li>
<li><p class="first"><strong>label_names</strong> (<em>list of strings</em>) – The names of the labels. The length of the list is n_labels. Note that, contrary to the respective nibabel function, this function will always return this as a list of strings, no matter the Python version used.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.annotation_file</cite> : the file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.read_label_md">
<code class="descclassname">brainload.annotations.</code><code class="descname">read_label_md</code><span class="sig-paren">(</span><em>label_file</em>, <em>hemisphere_label</em>, <em>meta_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.read_label_md" title="Permalink to this definition">¶</a></dt>
<dd><p>Read label file and record meta data for it.</p>
<p>A label file is a FreeSurfer text file like ‘subject/label/lh.cortex.label’ that contains a list of vertex ids (with RAS coordinates) that are part of the label. It may optionally contain a scalar values for each vertex, but that is currently ignored by this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>label_file</strong> (<em>string</em>) – A string representing a path to a FreeSurfer vertex annotation file (e.g., the path to ‘lh.cortex.label’).</li>
<li><strong>hemisphere_label</strong> (<em>{'lh'</em><em> or </em><em>'rh'}</em>) – A string representing the hemisphere this file belongs to. This is used to write the correct meta data.</li>
<li><strong>meta_data</strong> (<em>dictionary | None</em><em>, </em><em>optional</em>) – Meta data to merge into the output <cite>meta_data</cite>. Defaults to the empty dictionary.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><p class="first"><strong>verts_in_label</strong> (<em>ndarray, shape (num_labeled_verts,)</em>) – Contains an array of vertex ids, one id for each vertex that is part of the label.</p>
</li>
<li><p class="first"><strong>meta_data</strong> (<em>dictionary</em>) –</p>
<dl class="docutils">
<dt>Contains detailed information on the data that was loaded. The following keys are available (replace <cite>?h</cite> with the value of the argument <cite>hemisphere_label</cite>, which must be ‘lh’ or ‘rh’).</dt>
<dd><ul class="first last simple">
<li><cite>?h.label_file</cite> : the file that was loaded</li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.read_vertex_list_file">
<code class="descclassname">brainload.annotations.</code><code class="descname">read_vertex_list_file</code><span class="sig-paren">(</span><em>file_name</em>, <em>sep=' '</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.read_vertex_list_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a vertex list from a text file.</p>
<p>Read a vertex list from a text file. The file must contain vertex indices (integers) separated by spaces. It is OK if it has several lines. Lines starting with ‘#’ are considered to be comments and ignored. Note that a vertex is given by its index in a brain mesh, starting at 0. This is used as a way to import a list of vertices, similar to a FreeSurfer label file. This is a brainload custom format, but a very simple one that follows common file format conventions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_name</strong> (<em>str</em>) – Path to a file to read</li>
<li><strong>sep</strong> (<em>str</em><em>, </em><em>optional</em>) – Separator between integer values on a line. Defaults to a space, ‘ ‘.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The data read from all non-comment lines.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy 1D int array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.region_data_native">
<code class="descclassname">brainload.annotations.</code><code class="descname">region_data_native</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>annotation</em>, <em>hemi</em>, <em>morphometry_data</em>, <em>morphometry_meta_data</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.region_data_native" title="Permalink to this definition">¶</a></dt>
<dd><p>Get morphometry data for atlas regions.</p>
<p>Get morphometry data for each region in an annotation file/atlas. You can use these to compute anatomical statistics per region, like average cortical thickness.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subject_id</strong> (<em>string</em>) – The subject identifier.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – A string representing the path to the subjects dir.</li>
<li><strong>annotation</strong> (<em>string</em>) – An annotation to load, part of the file name of the respective file in the subjects label directory. E.g., ‘aparc’, ‘aparc.a2009s’, or ‘aparc.DKTatlas’.</li>
<li><strong>hemi</strong> (<em>string</em><em>, </em><em>one of {'both'</em><em>, </em><em>'lh'</em><em>, </em><em>'rh'}</em>) – The hemisphere for which data should actually be loaded.</li>
<li><strong>morphometry_data</strong> (<em>numpy array</em>) – morphometry data array, one value per vertex</li>
<li><strong>morphometry_meta_data</strong> (<em>dictionary</em>) – morphometry meta data dictionary, as returned by the functions that load morphometry data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>region_data_per_hemi</strong> (<em>nested dictionary</em>) – Has a key for each hemi you requested (only ‘lh’, only ‘rh’, or both ‘lh’ and ‘rh’). The inner one has the region names as keys, and a 1D numpy array of values.</li>
<li><strong>label_names</strong> (<em>list of strings</em>) – Names of the atlas regions. The length differs by atlas/annotation file.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Let us compute the average thickness in region 5 of the aparc atlas for a subject:
&gt;&gt;&gt; hemi = ‘lh’
&gt;&gt;&gt; morphometry_data, morphometry_meta_data = bl.subject_data_native(‘subject1’, TEST_DATA_DIR, ‘thickness’, hemi)
&gt;&gt;&gt; region_data, label_names = an.region_data_native(‘subject1’, TEST_DATA_DIR, ‘aparc’, hemi, morphometry_data, morphometry_meta_data)
&gt;&gt;&gt; region_6_name = label_names[5]
&gt;&gt;&gt; mean_thickness_in_region_6 = np.mean(region_data[hemi][region_6_name])
&gt;&gt;&gt; print(“Avg thickness in region ‘%s’ is: %f” % (region_6_name, mean_thickness_in_region_6))</p>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.region_stats">
<code class="descclassname">brainload.annotations.</code><code class="descname">region_stats</code><span class="sig-paren">(</span><em>region_data_per_hemi</em>, <em>label_names</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.region_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute descriptive stats for all regions. Return as 2D matrix.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.annotations.vertices_to_label">
<code class="descclassname">brainload.annotations.</code><code class="descname">vertices_to_label</code><span class="sig-paren">(</span><em>selected_vert_indices</em>, <em>all_vert_coords</em>, <em>header='#!ascii label'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.annotations.vertices_to_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a string in FreeSurfer label format from the vertices.</p>
<p>Write a string in FreeSurfer label format from the vertices. This can be used to create a label from a list of vertices, e.g., for displaying the vertices in Freeview or other tools supporting FreeSurfers label file format.</p>
</dd></dl>

</div>
<div class="section" id="module-brainload.nitools">
<span id="brainload-nitools-module"></span><h2>brainload.nitools module<a class="headerlink" href="#module-brainload.nitools" title="Permalink to this headline">¶</a></h2>
<p>Utility functions for loading neuroimaging data.</p>
<p>Most of these functions interact with the filesystem to find data.</p>
<dl class="function">
<dt id="brainload.nitools.detect_subjects_in_directory">
<code class="descclassname">brainload.nitools.</code><code class="descname">detect_subjects_in_directory</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>ignore_dir_names=None</em>, <em>required_subdirs_for_hits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.detect_subjects_in_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for directories containing FreeSurfer output in a directory and return the subject names.</p>
<p>Given a directory, search its sub directories for FreeSurfer data and return the directory names of all directories in which such data was found. The resulting list can be used
to create a subjects.txt file. This method searches all direct sub directories of the given subjects_dir for the existance of the typical FreeSurfer output directory structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_dir</strong> (<em>string</em>) – Path to a subjects directory.</li>
<li><strong>ignore_dir_names</strong> (<em>list of strings | None</em><em>, </em><em>optional</em>) – A list of directory names that should be ignored, even if they have the required sub directories. This is useful if you do not want to load certain subjects. It is often used to avoid loading the average subject ‘fsaverage’. Defaults to a list with the single element ‘fsaverage’. You can explicitely pass an empty list if you want to include all subjects.</li>
<li><strong>required_subdirs_for_hits</strong> (<em>list of strings | None</em>) – A sub directory of the given <cite>subjects_dir</cite> is considered a subject if it contains the typical FreeSurfer directory structure. Which sub directories are required is determined by this argument. If all of them are found under a dir, that dir is added tp the output list. This list defaults to a list with the single element ‘surf’. If that leads to false positives in your case, you could pass something like <cite>[‘surf’, ‘mri’, ‘label’]</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of the subject identifiers (or directories that were considered as such).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Guess which directories under the current SUBJECTS_DIR contain subject data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_subject_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;SUBJECTS_DIR&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_ids</span> <span class="o">=</span> <span class="n">nit</span><span class="o">.</span><span class="n">detect_subjects_in_directory</span><span class="p">(</span><span class="n">my_subject_dir</span><span class="p">,</span> <span class="n">ignore_dir_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fsaverage&#39;</span><span class="p">,</span> <span class="s1">&#39;Copy of subject4&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.nitools.do_subject_files_exist">
<code class="descclassname">brainload.nitools.</code><code class="descname">do_subject_files_exist</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em>, <em>filename=None</em>, <em>filename_template=None</em>, <em>sub_dir='surf'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.do_subject_files_exist" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks for the existance of certain files in each subject directory for a group of subjects.</p>
<p>Checks for the existance of certain files in the each subject directory for a group of subjects. This is useful to see whether data you intend to work on exists for all subjects you are interested in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_list</strong> (<em>list of strings</em>) – List of subject ids.</li>
<li><strong>subjects_dir</strong> (<em>string</em>) – Path to a directory that contains the subject data.</li>
<li><strong>filename</strong> (<em>string</em>) – A string representing the file name within the <cite>sub_dir</cite> sub directory of each subject, hardcoded. You must supply this or a <cite>filename_template</cite>.</li>
<li><strong>filename_template</strong> (<em>string</em>) – A string representing the file name within the ‘surf’ sub directory of each subject as a template. You must supply this or a <cite>filename</cite>, but not both. You can use the variable <cite>${SUBJECT_ID}</cite> in the template.</li>
<li><strong>sub_dir</strong> (<em>string | None</em><em>, </em><em>optional</em>) – The sub directory to look in. You could set any value, but the typical ones are the default FreeSurfer directories, e.g., ‘surf’, ‘mri’, ‘scripts’ and so on. You can set this to <cite>None</cite> if you want to look directly in the subjct’s dir, but FreeSurfer does not seem to store any data there by default. Defaults to ‘surf’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A dictionary. The keys are subjects that are missing the respective file, and the value is the absolute path of the file that is missing. If no files are missing, the dictionary is empty. If none of the subjects have the file, the length of the dictionary is equal to the length of the input <cite>subjects_list</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dictionary</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Check whether a file exists for all subjects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;subject4&#39;</span><span class="p">,</span> <span class="s1">&#39;subject7&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;my_study_x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">searched_file</span> <span class="o">=</span> <span class="s1">&#39;lh.area&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">missing</span> <span class="o">=</span> <span class="n">nit</span><span class="o">.</span><span class="n">do_subject_files_exist</span><span class="p">(</span><span class="n">subjects_list</span><span class="p">,</span> <span class="n">subjects_dir</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">searched_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;The file &#39;</span><span class="si">%s</span><span class="s2">&#39; exists for </span><span class="si">%d</span><span class="s2"> of the </span><span class="si">%d</span><span class="s2"> subjects.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">searched_file</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">subjects_list</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.nitools.fill_template_filename">
<code class="descclassname">brainload.nitools.</code><code class="descname">fill_template_filename</code><span class="sig-paren">(</span><em>template_string</em>, <em>substitution_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.fill_template_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace variables in the template with the respective substitution dict entries.</p>
<p>Checks the <cite>template_string</cite> for variables (i.e., something like ‘${VAR_NAME}’) that are listed as keys in <cite>substitution_dict</cite>. If such entries are found, they are replaced with the respective values in the <cite>substitution_dict</cite>. This function only calls <cite>ting.Template().substitute()</cite> in the background.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>template_string</strong> (<em>string</em>) – A template string, see the <cite>string.Template</cite> constructor in the standard Python <cite>string</cite> module. Variable names must be enclosed in <cite>${}</cite>. Example: <cite>${SUBJECT_ID}_hardcoded_text</cite>.</li>
<li><strong>substitution_dict</strong> (<em>dictionary string</em><em>, </em><em>string</em>) – The keys are variable names, values are the replacements. See <cite>string.Template.substitute</cite> in the standard Python <cite>string</cite> module. Example: <cite>{ ‘SUBJECT_ID’ : ‘subject3’ }</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result of the replacement.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Fill in a template string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template_str</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="si">{HEMI}</span><span class="s1">.white&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitution_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;HEMI&#39;</span> <span class="p">:</span> <span class="s1">&#39;lh&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">nit</span><span class="o">.</span><span class="n">fill_template_filename</span><span class="p">(</span><span class="n">template_str</span><span class="p">,</span> <span class="n">substitution_dict</span><span class="p">)</span>
<span class="go">lh.white</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.nitools.load_vertex_indices">
<code class="descclassname">brainload.nitools.</code><code class="descname">load_vertex_indices</code><span class="sig-paren">(</span><em>vertex_indices_file</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.load_vertex_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.nitools.load_voxel_indices">
<code class="descclassname">brainload.nitools.</code><code class="descname">load_voxel_indices</code><span class="sig-paren">(</span><em>vertex_indices_file</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.load_voxel_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.nitools.read_BIDS_participants_file">
<code class="descclassname">brainload.nitools.</code><code class="descname">read_BIDS_participants_file</code><span class="sig-paren">(</span><em>participants_file</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.read_BIDS_participants_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read all subjects from BIDS participants file.</p>
<p>The file must a tab-separated text file with an arbitrary number of columns and one header line. Exactly one of the columns must be named ‘participants_id’. The file should be name ‘participants.tsv’, but this is not enforced. See <a class="reference external" href="https://www.nature.com/articles/sdata201644">https://www.nature.com/articles/sdata201644</a> for details on BIDS, the Brain Imaging Data Structure standard.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.nitools.read_subjects_file">
<code class="descclassname">brainload.nitools.</code><code class="descname">read_subjects_file</code><span class="sig-paren">(</span><em>subjects_file</em>, <em>has_header_line=False</em>, <em>index_of_subject_id_field=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.read_subjects_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a subjects file in CSV format that has the subject id as the first entry on each line. Arbitrary data may follow in the consecutive fields on each line, and will be ignored. Having nothing but the subject id on the line is also fine, of course.</p>
<p>The file can be a simple text file that contains one <cite>subject_id</cite> per line. It can also be a CSV file that has other data following, but the <cite>subject_id</cite> has to be the first item on each line and the separator must be a comma. So a line is allowed to look like this: <cite>subject1, 35, center1, 147</cite>. No header is allowed. If you have a different format, consider reading the file yourself and pass the result as <cite>subjects_list</cite> instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_file</strong> (<em>string</em>) – Path to a subjects file (see above for format details).</li>
<li><strong>has_header_line</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether the first line is a header line and should be skipped. Defaults to ‘False’.</li>
<li><strong>index_of_subject_id_field</strong> (<em>integer</em><em>, </em><em>optional</em>) – The column index of the field that contains the subject id in each row. Defaults to ‘0’. Changing this only makes sense for CSV files.</li>
<li><strong>**kwargs</strong> (<em>any</em>) – Any other named arguments will be passed on to the call to the call to the <cite>csv.reader</cite> constructor. That is a class from Python’s standard <cite>csv</cite> module. Example: pass <cite>delimiter=’    ‘</cite> if your CSV file is limited by tabs.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of subject identifiers.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of strings</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load a list of subjects from a simple text file that contains one subject per line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.nitools</span> <span class="k">as</span> <span class="nn">nit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subjects_ids</span> <span class="o">=</span> <span class="n">nit</span><span class="o">.</span><span class="n">read_subjects_file</span><span class="p">(</span><span class="s1">&#39;/home/myuser/data/study5/subjects.txt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.nitools.save_vertex_indices">
<code class="descclassname">brainload.nitools.</code><code class="descname">save_vertex_indices</code><span class="sig-paren">(</span><em>vertex_indices_file</em>, <em>vertex_indices</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.save_vertex_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.nitools.write_BIDS_participants_file">
<code class="descclassname">brainload.nitools.</code><code class="descname">write_BIDS_participants_file</code><span class="sig-paren">(</span><em>file_name</em>, <em>subjects_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.write_BIDS_participants_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.nitools.write_lines_to_text_file">
<code class="descclassname">brainload.nitools.</code><code class="descname">write_lines_to_text_file</code><span class="sig-paren">(</span><em>lines</em>, <em>file_name</em>, <em>line_sep='\n'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.write_lines_to_text_file" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Write the lines to a text file.</p>
<p>Write the lines to a text file, overwriting it in case it exists.</p>
<dl class="docutils">
<dt>lines: list of str</dt>
<dd>The lines, must not contain line ending.</dd>
<dt>file_name: str</dt>
<dd>Path to new text file to create (or overwrite if it exists).</dd>
<dt>line_sep: str, optional</dt>
<dd>Line separator. Defaults to “</dd>
</dl>
</div></blockquote>
<p>“.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.nitools.write_subjects_file">
<code class="descclassname">brainload.nitools.</code><code class="descname">write_subjects_file</code><span class="sig-paren">(</span><em>file_name</em>, <em>subjects_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.nitools.write_subjects_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-brainload.brainlocate">
<span id="brainload-brainlocate-module"></span><h2>brainload.brainlocate module<a class="headerlink" href="#module-brainload.brainlocate" title="Permalink to this headline">¶</a></h2>
<p>Find vertices closest to a given coordinate in a brain surface mesh. Some of these functions require scipy, which is an optional dependency and needs to be installed manually.</p>
<dl class="class">
<dt id="brainload.brainlocate.BrainLocate">
<em class="property">class </em><code class="descclassname">brainload.brainlocate.</code><code class="descname">BrainLocate</code><span class="sig-paren">(</span><em>vert_coords</em>, <em>faces</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainlocate.BrainLocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="brainload.brainlocate.BrainLocate.get_closest_vertex">
<code class="descname">get_closest_vertex</code><span class="sig-paren">(</span><em>query_coords</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainlocate.BrainLocate.get_closest_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the vertex closest to each of the given coordinates. Requires scipy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_coords</strong> (<em>numpy 2D array</em>) – The coordinates, given as a numeric array with shape (n, 3) for n coords.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Array with shape (n, ). Each value represents the index of the vertex closest to the respective query coordinate.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 1D array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.brainlocate.BrainLocate.get_closest_vertex_and_distance">
<code class="descname">get_closest_vertex_and_distance</code><span class="sig-paren">(</span><em>query_coords</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainlocate.BrainLocate.get_closest_vertex_and_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the vertex closest to each of the given coordinates, and the respective distance. Requires scipy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_coords</strong> (<em>numpy 2D array</em>) – The coordinates, given as a numeric array with shape (n, 3) for n coords.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Array with shape (n, 2). Each row represents the index of the vertex closest to the respective query coordinate (at index 0) and the respective distance (at index 1).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 1D array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainload.brainvoxlocate">
<span id="brainload-brainvoxlocate-module"></span><h2>brainload.brainvoxlocate module<a class="headerlink" href="#module-brainload.brainvoxlocate" title="Permalink to this headline">¶</a></h2>
<p>Given a voxel in a brain volume, find the FreeSurfer region it lies in (or the closest one if it is not in any region).</p>
<dl class="class">
<dt id="brainload.brainvoxlocate.BrainVoxLocate">
<em class="property">class </em><code class="descclassname">brainload.brainvoxlocate.</code><code class="descname">BrainVoxLocate</code><span class="sig-paren">(</span><em>volume_file</em>, <em>lookup_file</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainvoxlocate.BrainVoxLocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Voxel segmentation label locator. This class allows you to determine the label (both label code/number and label name) from a lookup table file (usually FreeSurferColorLUT.txt) that is assigned to a voxel in a segmentation output volume (like aseg.mgz or aparc+asgeg.mgz).</p>
<p class="rubric">Examples</p>
<p>Initialize a locator based on a volume (a segmentation output, i.e., the value assigned to each voxel in the volume represents the tissue class it has been assigned to by the segmentation) and a lookup table file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;mri&#39;</span><span class="p">,</span> <span class="s1">&#39;aseg.mgz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;fs&#39;</span><span class="p">,</span> <span class="s1">&#39;FreeSurferColorLUT.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locator</span> <span class="o">=</span> <span class="n">vloc</span><span class="o">.</span><span class="n">BrainVoxLocate</span><span class="p">(</span><span class="n">volume_file</span><span class="p">,</span> <span class="n">lookup_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Now define some voxels we are interested in. Voxels are given by their column, row, slice (RCS) indices in the volume. These always start at 0 and range from 0 to d-1, where d is the length of the volume along the respective axis. So if your volume file has shape (128, 128, 128), the 3 indices along the 3 axes all range from 0 to 127.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">query_vox_crs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="mi">45</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>Now get the classes of exactly these voxels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seg_code</span><span class="p">,</span> <span class="n">seg_name</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="n">get_voxel_segmentation_labels</span><span class="p">(</span><span class="n">query_vox_crs</span><span class="p">)</span>
</pre></div>
</div>
<p>Now print the code and the string for the first query voxel, (24, 28, 20):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Voxel has label code </span><span class="si">%d</span><span class="s2">, which encodes label string &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">seg_code</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">seg_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>Note that some voxels may not be assigned any label. These will show the label code 0, which means label name ‘Unknown’. Sometimes, you may want to know the label of the closest voxel which has a valid label for these. For example, because you want to know the brain structure that is closest to this voxel, even if the point does not lie within that structure. You can do this and allow a certain neighborhood to be searched with the <code class="docutils literal notranslate"><span class="pre">`get_closest_not_unknown`</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">voxels</span><span class="p">,</span> <span class="n">codes</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">closest_voxels_ras_coords</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="n">get_closest_not_unknown</span><span class="p">(</span><span class="n">query_vox_crs</span><span class="p">)</span>
</pre></div>
</div>
<p>See the documentation for that function for details on the return values.</p>
<dl class="method">
<dt id="brainload.brainvoxlocate.BrainVoxLocate.get_closest_not_unknown">
<code class="descname">get_closest_not_unknown</code><span class="sig-paren">(</span><em>query_voxels_crs</em>, <em>unknown_label=0</em>, <em>neighborhood_size=10</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainvoxlocate.BrainVoxLocate.get_closest_not_unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the closest voxels which have a non-empty label.</p>
<p>Determine the closest voxels which have a non-empty label, their labels, and the respective distance. Requires scipy. This allow you to determine the brain structure closest to a voxel (within a distance threshold), even if the voxel idoes not lie directly within the brain structure. This function uses Euclidian distance to determine which voxel is closest (but it only checks voxels with the given neighborhood, of course). If one of the query voxels lies directly within a brains structure (i.e., the voxel itself has a valid label), that label will be returned and the distance will be 0.0, of course.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>query_voxels_crs</strong> (<em>numpy 2D array of int</em>) – The query voxels, each given by its CRS indices. So the shape is (n, 3) for n query voxels.</li>
<li><strong>neighborhood_size</strong> (<em>int</em><em>, </em><em>optional</em>) – Distance threshold in voxels along each direction of each axis, must be a positive integer or zero. Only the neighborhood of each query voxel will be searched. Example: If you pass 0, only the voxel itself is searched. If you pass 1, up to 3x3 = 27 voxels around it will be searched. If you pass 3, up to 7x7x7 = 343 voxels will be searched. The ‘up to’ refers to the case where the query voxel is at the border of the volume. In that case, some of the voxels do not exist (and thus are not checked). Defaults to 10. Note that if you set this to a very large value, a pairwise distance matrix of considerable size has to be computed, which may take some time. E.g., if you set it to 100, the distances between 201x201x201=8,120,601 voxels will be computed. This means that 8120601 ^ 2 / 2 - 8120601 = 32,972,072,179,999 distances need to be computed. No matter what you put, only valid voxel indices within the volume will be used for computation.</li>
<li><strong>unknown_label</strong> (<em>int</em><em>, </em><em>optional</em>) – The segmentation value that represents the ‘Unknown’ class. Defaults to 0, which is suitable for the FreeSurferColorLUT.txt file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>voxels</strong> (<em>numpy 2D int array</em>) – The result voxels, one for each query voxel. Each voxel is given by its CRS indices. So the shape is (n, 3) for n query voxels. If no suitable voxel with non-empty label code was found for a query voxel, the coordinates are [-1, -1, -1].</li>
<li><strong>codes</strong> (<em>numpy 1D int array</em>) – The label codes for the result voxels. If no suitable voxel with non-empty label code was found for a query voxel, the code is -1.</li>
<li><strong>distances</strong> (<em>numpy 1D float array</em>) – The distances from the respective query voxel to the result voxel. These are determined from the RAS coordinates of the voxel pair, using the ras2vox and vox2ras matrices in the volume file header. (The distance is 0.0 if the query voxel itself has a nonzero label.) If no suitable voxel with non-empty label code was found for a query voxel, the distance is -1.0f.</li>
<li><strong>closest_voxels_ras_coords</strong> (<em>numpy 2D float array</em>) – The RAS coordinates of the chosen voxel. If the query voxel has a none-empty label, this is its own coordinate. Otherwise, it is the coordinate of the closest voxel with valid label. If no such voxel was found, the coordinates are [-1.0, -1.0, -1.0]. Note that this could theoretically be a valid RAS coordinate, so you should not use this field to determine whether a valid voxel was found. Use the <code class="docutils literal notranslate"><span class="pre">`voxels`</span></code> return value for that.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Initialize a locator based on a volume (a segmentation output, i.e., the value assigned to each voxel in the volume represents the tissue class it has been assigned to by the segmentation) and a lookup table file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;mri&#39;</span><span class="p">,</span> <span class="s1">&#39;aseg.mgz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;fs&#39;</span><span class="p">,</span> <span class="s1">&#39;FreeSurferColorLUT.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locator</span> <span class="o">=</span> <span class="n">vloc</span><span class="o">.</span><span class="n">BrainVoxLocate</span><span class="p">(</span><span class="n">volume_file</span><span class="p">,</span> <span class="n">lookup_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Now define some voxels we are interested in. Voxels are given by their column, row, slice (RCS) indices in the volume. These always start at 0 and range from 0 to d-1, where d is the length of the volume along the respective axis. So if your volume file has shape (128, 128, 128), the 3 indices along the 3 axes all range from 0 to 127.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">query_vox_crs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="mi">45</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>Now get the classes of these voxels. If the voxel itself has no label (i.e., it has the ‘Unknown’ label), search with a square neighborhood of 5 voxels along each direction of each axis for the closest valid label.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">voxels</span><span class="p">,</span> <span class="n">codes</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">closest_voxels_ras_coords</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="n">get_closest_not_unknown</span><span class="p">(</span><span class="n">query_vox_crs</span><span class="p">,</span> <span class="n">neighborhood_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="brainload.brainvoxlocate.BrainVoxLocate.get_ras_coords_at_voxel_crs">
<code class="descname">get_ras_coords_at_voxel_crs</code><span class="sig-paren">(</span><em>query_crs_coords</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainvoxlocate.BrainVoxLocate.get_ras_coords_at_voxel_crs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the RAS coord of each voxel.</p>
<p>Find the RAS coord of each voxel. A voxel is identified by its indices along the 3 axes, also knows as CRS (column, row, slice). The computation is based on the ras2vox matrix in the file header.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_crs_coords</strong> (<em>numpy 2D int array</em>) – The 3D row, column, slice indices for each voxel, given as a numeric array with shape (n, 3) for n voxels.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Array with shape (n, 3) representing the RAS coordinates in the volume file (x,y,z).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 2D float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.brainvoxlocate.BrainVoxLocate.get_voxel_crs_at_ras_coords">
<code class="descname">get_voxel_crs_at_ras_coords</code><span class="sig-paren">(</span><em>query_coords</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainvoxlocate.BrainVoxLocate.get_voxel_crs_at_ras_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the voxel closest to each of the given coordinates.</p>
<p>Find the voxel closest to each of the given coordinates. A voxel is identified by its indices along the 3 axes, also knows as CRS (column, row, slice). The computation is based on the ras2vox matrix in the file header.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_coords</strong> (<em>numpy 2D float array</em>) – The 3D coordinates, given as a numeric array with shape (n, 3) for n coords.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Array with shape (n, 3) representing the voxel indices in the volume file.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy 2D int array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.brainvoxlocate.BrainVoxLocate.get_voxel_segmentation_labels">
<code class="descname">get_voxel_segmentation_labels</code><span class="sig-paren">(</span><em>query_voxels_crs</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainvoxlocate.BrainVoxLocate.get_voxel_segmentation_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the exact labels for the given voxels.</p>
<p>Find the exact labels for the given voxels. All voxels will have a label, but label 0 means ‘Unknown’. (Sometimes, you may want to know the label of the closest voxel which has a valid label for these. For example, because you want to know the brain structure that is closest to this voxel, even if the point does not lie within that structure. See the function <code class="docutils literal notranslate"><span class="pre">`get_closest_not_unknown`</span></code> for that use case.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query_vox_crs</strong> (<em>numpy 2D array of int</em>) – The query voxels, each given by its CRS indices. So the shape is (n, 3) for n query voxels.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>voxel_seg_code</strong> (<em>numpy 1D int array</em>) – The voxel segmentation codes from the lookup file. All voxels will have a label, but label 0 means ‘Unknown’.</li>
<li><strong>voxel_seg_name</strong> (<em>numpy 1D str array</em>) – The voxel segmentation names from the lookup file. All voxels will have a label, but label 0 means ‘Unknown’.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Initialize a locator based on a volume (a segmentation output, i.e., the value assigned to each voxel in the volume represents the tissue class it has been assigned to by the segmentation) and a lookup table file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;mri&#39;</span><span class="p">,</span> <span class="s1">&#39;aseg.mgz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">TEST_DATA_DIR</span><span class="p">,</span> <span class="s1">&#39;fs&#39;</span><span class="p">,</span> <span class="s1">&#39;FreeSurferColorLUT.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locator</span> <span class="o">=</span> <span class="n">vloc</span><span class="o">.</span><span class="n">BrainVoxLocate</span><span class="p">(</span><span class="n">volume_file</span><span class="p">,</span> <span class="n">lookup_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Now define some voxels we are interested in. Voxels are given by their column, row, slice (RCS) indices in the volume. These always start at 0 and range from 0 to d-1, where d is the length of the volume along the respective axis. So if your volume file has shape (128, 128, 128), the 3 indices along the 3 axes all range from 0 to 127.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">query_vox_crs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="mi">45</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>Now get the classes of exactly these voxels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seg_code</span><span class="p">,</span> <span class="n">seg_name</span> <span class="o">=</span> <span class="n">locator</span><span class="o">.</span><span class="n">get_voxel_segmentation_labels</span><span class="p">(</span><span class="n">query_vox_crs</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">`get_closest_not_unknown`</span></code> can find the brain structure closest to a voxel, even if the voxel does not lie within that structure.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainload.brainwrite">
<span id="brainload-brainwrite-module"></span><h2>brainload.brainwrite module<a class="headerlink" href="#module-brainload.brainwrite" title="Permalink to this headline">¶</a></h2>
<p>Some functions for writing brain data to files.</p>
<p>These functions are helpful if you want to generate and write volume or surface data.</p>
<dl class="function">
<dt id="brainload.brainwrite.get_surface_vertices_overlay_text_file_lines">
<code class="descclassname">brainload.brainwrite.</code><code class="descname">get_surface_vertices_overlay_text_file_lines</code><span class="sig-paren">(</span><em>num_verts, vertex_mark_list, background_rgb=[200, 200, 200], dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainwrite.get_surface_vertices_overlay_text_file_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface overlay as a text file.</p>
<p>Performs the same task as get_surface_vertices_overlay_volume_data, but outputs the data as lines that can be written to a text file. This is an alternate format for a surface overlay file. You can write the returned lines to a text file and load the result as a surface colormap in Freeview: load a surface like <code class="docutils literal notranslate"><span class="pre">`lh.pial`</span></code>, select it on the left pane and then click <code class="docutils literal notranslate"><span class="pre">`Color</span> <span class="pre">-&gt;</span> <span class="pre">Load</span> <span class="pre">RGB</span> <span class="pre">Map...`</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num_verts</strong> (<em>int</em>) – The number of vertices of the surface. E.g., 163842 if you want to color vertices on a hemisphere from the fsaverage Freesurfer subject.</li>
<li><strong>vertex_mark_list</strong> (<em>list of tuples</em>) – Each tuple contains first the voxel indices (1D numpy int array with shape (n, ) for n vertices) and then a 1D array of length 3 that represents the RGB values of the color to assign to all the previously given n vertices.</li>
<li><strong>background_rgb</strong> (<em>numpy 1D array of length 3</em><em>, </em><em>optional</em>) – The background color, defined as 3 RGB values. Defaults to [200, 200, 200], which is a bright gray. This is assigned to all vertices which do not occur in vertex_mark_list.</li>
<li><strong>dtype</strong> (<em>data type</em><em>, </em><em>optional</em>) – The data type of the returned data 3D array. Defaults to <code class="docutils literal notranslate"><span class="pre">`np.uint8`</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lines</strong> – A list of lines that can be written to a text file as a surface overlay. Each line represents the color of a single vertex. Vertex order is the same as the order of vertices in the surface file that this overlay is for.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.brainwrite.get_surface_vertices_overlay_volume_data">
<code class="descclassname">brainload.brainwrite.</code><code class="descname">get_surface_vertices_overlay_volume_data</code><span class="sig-paren">(</span><em>num_verts, vertex_mark_list, background_rgb=[200, 200, 200], dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainwrite.get_surface_vertices_overlay_volume_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface overlay as a binary volume image file.</p>
<p>Generates a surface overlay volume. The volume contains one color value per vertex of the surface and can be used to visualize different vertices on a brain surface. This functions supports coloring different sets of vertices with different colors. All vertices which are not explicitely listed with a color to assign to them are given the background color. You can write the result volume to an  mgz file and load the result as a surface overlay in Freeview: load a surface like <code class="docutils literal notranslate"><span class="pre">`lh.pial`</span></code>, select it on the left pane and then click <code class="docutils literal notranslate"><span class="pre">`Overlay</span> <span class="pre">-&gt;</span> <span class="pre">Load</span> <span class="pre">generic...`</span></code>. Note that saving to nifti will not work in many cases (depends on num_verts), as the dimensions are usually too large to be saved to nifti formats.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num_verts</strong> (<em>int</em>) – The number of vertices of the surface. E.g., 163842 if you want to color vertices on a hemisphere from the fsaverage Freesurfer subject.</li>
<li><strong>vertex_mark_list</strong> (<em>list of tuples</em>) – Each tuple contains first the voxel indices (1D numpy int array with shape (n, ) for n vertices) and then a 1D array of length 3 that represents the RGB values of the color to assign to all the previously given n vertices.</li>
<li><strong>background_rgb</strong> (<em>numpy 1D array of length 3</em><em>, </em><em>optional</em>) – The background color, defined as 3 RGB values. Defaults to [200, 200, 200], which is a bright gray. This is assigned to all vertices which do not occur in vertex_mark_list.</li>
<li><strong>dtype</strong> (<em>data type</em><em>, </em><em>optional</em>) – The data type of the returned data 3D array. Defaults to <code class="docutils literal notranslate"><span class="pre">`np.uint8`</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>voxel_data</strong> – A 3D array with shape (n, 3, 1) for the n vertices of the surface that contains the colors given by the 3 RGB values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy 3D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create an overlay for an fsaverage hemisphere (which always has exactly 163842 vertices) and mark 3 of the vertices in red and 4 others in green. The rest will be gray.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_verts</span> <span class="o">=</span> <span class="mi">163842</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_mark_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vol_data</span> <span class="o">=</span> <span class="n">bw</span><span class="o">.</span><span class="n">get_surface_vertices_overlay_volume_data</span><span class="p">(</span><span class="n">num_verts</span><span class="p">,</span> <span class="n">vertex_mark_list</span><span class="p">,</span> <span class="n">background_rgb</span><span class="o">=</span><span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">])</span>
</pre></div>
</div>
<p>You could now write this to a nifti or mgz file and load it as a surface overlay.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">`get_surface_vertices_overlay_volume_data_1color`</span></code>: the same data, but use one intensity value per vertex instead of 3 RGB values. Allows usage of FreeSurfer hack for saving to nifti format in case of fsaverage.
<code class="docutils literal notranslate"><span class="pre">`get_surface_vertices_overlay_text_file_lines`</span></code>: the same data, but for writing to a similar file in text format that can be loaded as a color map. Uses RGB color. No dimension limitations.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.brainwrite.get_surface_vertices_overlay_volume_data_1color">
<code class="descclassname">brainload.brainwrite.</code><code class="descname">get_surface_vertices_overlay_volume_data_1color</code><span class="sig-paren">(</span><em>num_verts</em>, <em>vertex_mark_list</em>, <em>background_value=0</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainwrite.get_surface_vertices_overlay_volume_data_1color" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface overlay as a binary volume image file.</p>
<p>Generates a surface overlay volume. The volume contains one color value per vertex of the surface and can be used to visualize different vertices on a brain surface. This functions supports coloring different sets of vertices with different colors. All vertices which are not explicitely listed with a color to assign to them are given the background color. You can write the result volume to a nifti or mgz file and load the result as a surface overlay in Freeview: load a surface like <code class="docutils literal notranslate"><span class="pre">`lh.pial`</span></code>, select it on the left pane and then click <code class="docutils literal notranslate"><span class="pre">`Overlay</span> <span class="pre">-&gt;</span> <span class="pre">Load</span> <span class="pre">generic...`</span></code>. Note that saving to nifti will only works if num_verts is exactly 163842, the number of vertices of fsaverage, as it abuses the FreeSurfer hack to save large dimensions in nifti files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num_verts</strong> (<em>int</em>) – The number of vertices of the surface. E.g., 163842 if you want to color vertices on a hemisphere from the fsaverage Freesurfer subject.</li>
<li><strong>vertex_mark_list</strong> (<em>list of tuples</em>) – Each tuple contains first the voxel indices (1D numpy int array with shape (n, ) for n vertices) and then an int that represents the intenstiy value to all the previously given n vertices.</li>
<li><strong>background_value</strong> (<em>int</em><em>, </em><em>optional</em>) – The background value. This is assigned to all vertices which do not occur in vertex_mark_list.</li>
<li><strong>dtype</strong> (<em>data type</em><em>, </em><em>optional</em>) – The data type of the returned data 3D array. Defaults to <code class="docutils literal notranslate"><span class="pre">`np.uint8`</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>voxel_data</strong> – A 3D array with shape (n, 1, 1) for the n vertices of the surface.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy 3D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create an overlay for an fsaverage hemisphere (which always has exactly 163842 vertices) and mark 3 of the vertices in red and 4 others in green. The rest will be gray.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_verts</span> <span class="o">=</span> <span class="mi">163842</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertex_mark_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vol_data</span> <span class="o">=</span> <span class="n">bw</span><span class="o">.</span><span class="n">get_surface_vertices_overlay_volume_data</span><span class="p">(</span><span class="n">num_verts</span><span class="p">,</span> <span class="n">vertex_mark_list</span><span class="p">,</span> <span class="n">background_rgb</span><span class="o">=</span><span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">])</span>
</pre></div>
</div>
<p>You could now write this to a nifti or mgz file and load it as a surface overlay.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">`get_surface_vertices_overlay_volume_data`</span></code>: the same data, but for writing to a similar file in text format</p>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.brainwrite.get_volume_data_with_custom_marks">
<code class="descclassname">brainload.brainwrite.</code><code class="descname">get_volume_data_with_custom_marks</code><span class="sig-paren">(</span><em>voxel_mark_list</em>, <em>background_voxel_value=0</em>, <em>shape=(256</em>, <em>256</em>, <em>256)</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainwrite.get_volume_data_with_custom_marks" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a volume in which the target voxels are marked by the individual colors assigned to each voxel array in the list.</p>
<p>Generate a volume in which the values of all target_voxel_indices are set to a target_voxel_value that can be defined separately for each subject/entry in the list. This is useful for visualizing the voxels in a 3D viewer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>voxel_mark_list</strong> (<em>list of tuples</em>) – Each tuple contains first the voxel indices (2D numpy int array with shape (n, 3)) and then a single integer, the voxel value to use for the voxel indices.</li>
<li><strong>background_voxel_value</strong> (<em>np.uint8</em><em>, </em><em>optional</em>) – The value to assign to all voxels which are not in the voxel_mark_list, i.e., the background voxels. Defaults to 0. The type must match the dtype parameter.</li>
<li><strong>shape</strong> (<em>tupel of int</em><em>, </em><em>optional</em>) – The shape of the 3D volume, i.e., the number of voxels along the 3 dimensions. Defaults to (256, 256, 256).</li>
<li><strong>dtype</strong> (<em>datatype</em><em>, </em><em>optional</em>) – The data type of the returned data 3D array. Defaults to <code class="docutils literal notranslate"><span class="pre">`np.uint8`</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>voxel_data</strong> – The shape depends on the shape parameter, and the data type on the dtype parameter of this function. The voxels within this 3D volume are marked with the requested target values (or the background value).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy multi-dimensional array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create volume data with shape 256x256x256 in which 2 voxels are marked with intensity value 40, and 2 other voxels with intensity value 160:
&gt;&gt;&gt; import brainload.brainwrite as bw
&gt;&gt;&gt; voxel_mark_list = [(np.array([[15, 25, 30], [24, 24, 24]], dtype=int), 40), (np.array([[44, 44, 44], [55, 55, 55]], dtype=int), 160)]
&gt;&gt;&gt; vol_data = bw.get_volume_data_with_custom_marks(voxel_mark_list, background_voxel_value=0, shape=(256, 256, 256))</p>
<p>You could now write vol_data to a nifti file using nibabel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ni_img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">vol_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">ni_img</span><span class="p">,</span> <span class="s1">&#39;my_data.nii&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.brainwrite.write_voldata_to_mgh_file">
<code class="descclassname">brainload.brainwrite.</code><code class="descname">write_voldata_to_mgh_file</code><span class="sig-paren">(</span><em>mgh_file_name</em>, <em>vol_data</em>, <em>affine=None</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainwrite.write_voldata_to_mgh_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write volume data to a MGH format file.</p>
<p>Write the volume data to a file in MGH format. The format is from FreeSurfer and stores volume images. Unless you supply a header, the header will be pretty empty. Thin wrapper around nibabels <code class="docutils literal notranslate"><span class="pre">`MGHImage`</span></code> class and the <code class="docutils literal notranslate"><span class="pre">`to_filename`</span></code> method inherited from <code class="docutils literal notranslate"><span class="pre">`FileBasedImage`</span></code>. Note that if you just modified data that you loaded from a source image (e.g., you replaced some intensities), you should pass the affine and the header of the original image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mgh_file_name</strong> (<em>str</em>) – Path to output file. Will be overwritten if it exists. Should have file extension mgh.</li>
<li><strong>vol_data</strong> (<em>the data to write</em><em>, </em><em>usually a multi-dimensional numpy array. Shape could be</em><em> (</em><em>256</em><em>, </em><em>256</em><em>, </em><em>256</em><em>) </em><em>for a 3D image</em><em>, or </em><em>(</em><em>256</em><em>, </em><em>256</em><em>, </em><em>256</em><em>, </em><em>50</em><em>) </em><em>for a 4D image containing 50 time points</em><em>, </em><em>but this is up to you.</em>) – </li>
<li><strong>affine</strong> (<em>numpy 2D array</em><em>, </em><em>optional</em>) – The affine registration matrix (4x4) relating the voxel coordinates to world coordinates in RAS+ space. See nibabel docs for details.</li>
<li><strong>header</strong> (<em>nibabel.freesurfer.mghformat.MGHHeader</em><em>, </em><em>optional</em>) – The MGH file header. If not given, an empty default header will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.brainwrite.write_voldata_to_nifti_file">
<code class="descclassname">brainload.brainwrite.</code><code class="descname">write_voldata_to_nifti_file</code><span class="sig-paren">(</span><em>file_name</em>, <em>vol_data</em>, <em>affine=None</em>, <em>header=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.brainwrite.write_voldata_to_nifti_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write volume data to a nifti file.</p>
<p>Write the volume data to a file in NIFTI v1 format. Unless you supply a header, the header will be pretty empty. Very thin wrapper around nibabel.save. Note that if you just modified data that you loaded from a source image (e.g., you replaced some intensities), you should pass the affine and the header of the original image. They are available as orig_image.affine and orig_image.header, where orig_image is the return value of nibabel.load.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_name</strong> (<em>str</em>) – Path to output file. Will be overwritten if it exists. Should have file extension nii (or ngz for gzip compression).</li>
<li><strong>vol_data</strong> (<em>the data to write</em><em>, </em><em>usually a multi-dimensional numpy array. Shape could be</em><em> (</em><em>256</em><em>, </em><em>256</em><em>, </em><em>256</em><em>) </em><em>for a 3D image</em><em>, or </em><em>(</em><em>256</em><em>, </em><em>256</em><em>, </em><em>256</em><em>, </em><em>50</em><em>) </em><em>for a 4D image containing 50 time points</em><em>, </em><em>but this is up to you. Note however that the Nifti 1 format is limited in how large the individual dimensions may be and how many dimensions are supported. See nibabel for details.</em>) – </li>
<li><strong>affine</strong> (<em>numpy 2D array</em><em>, </em><em>optional</em>) – The affine registration matrix (4x4) relating the voxel coordinates to world coordinates in RAS+ space. See nibabel docs for details.</li>
<li><strong>header</strong> (<em>nibabel.Nifti1Header</em><em>, </em><em>optional</em>) – The nifti header. If not given, an almost empty default header will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-brainload.stats">
<span id="brainload-stats-module"></span><h2>brainload.stats module<a class="headerlink" href="#module-brainload.stats" title="Permalink to this headline">¶</a></h2>
<p>Functions for parsing FreeSurfer brain stat files.</p>
<p>You can use these to read files like <cite>subject/stats/aseg.stats</cite>. Note that these functions read the stats files for a single subject, typically from the ‘stats’ sub directory of that subject.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li>You could also use the FreeSurfer command ‘aparcstats2table’ to merge data from many subjects for a measure (like ‘thickness’) into a single file and parse that file. This is NOT what is done by these functions though, they are designed for the stats files that are generated by default.</li>
<li>The information in the <cite>aseg.stats</cite> file is of interest because many brain properties interact with brain volume or cortical thickness, so people often use these as covariates in their models.</li>
<li>The atlas stats files (e.g., <cite>lh.aparc.stats</cite>) contain information on the different brain regions, based on registering the respective subject to a brain atlas.</li>
</ul>
<dl class="function">
<dt id="brainload.stats.extract_column_from_table_data">
<code class="descclassname">brainload.stats.</code><code class="descname">extract_column_from_table_data</code><span class="sig-paren">(</span><em>all_subjects_table_data_dict</em>, <em>column_name_for_dict_keys</em>, <em>column_name_of_values</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.extract_column_from_table_data" title="Permalink to this definition">¶</a></dt>
<dd><p>For all rows and a single column, extract the data for all subjects.</p>
<p>For all rows and a single column, extract the data for all subjects. This results in a dictionary of vectors, representing the column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>all_subjects_table_data_dict</strong> (<em>dict of str to numpy 2D array</em>) – Data as returned by the <code class="docutils literal notranslate"><span class="pre">`group_stats`</span></code> function.</li>
<li><strong>column_name_for_dict_keys</strong> (<em>str</em>) – The column name (key in all_subjects_table_data) of the column of which the values in each row will be used to identify the output data. Think of this as labels.</li>
<li><strong>column_name_of_values</strong> (<em>str</em>) – The column name (key in all_subjects_table_data) of the column holding the values you want to retrieve.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The data for column column_name_of_values for all subjects. Each row is represented by one entry. The key is the value of the column column_name_for_dict_keys for the row (must be unique) and the value is the value of the column column_name_of_values. Note that you could turn this into a Pandas DataFrame very easily if you use Pandas.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dictionary string to numpy 1D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Load the aseg stats for a group of subjects in the pre-defined directory my_subjects_dir:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">all_subjects_table_data_dict</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">group_stats_aseg</span><span class="p">([</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;subject2&#39;</span><span class="p">],</span> <span class="n">my_subjects_dir</span><span class="p">)</span>
</pre></div>
</div>
<p>Now get the data for the number of voxels for all rows (=brain structures). Label the result with the structure name column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">column_data</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">extract_column_from_table_data</span><span class="p">(</span><span class="n">all_subjects_table_data_dict</span><span class="p">,</span> <span class="s1">&#39;StructName&#39;</span><span class="p">,</span> <span class="s1">&#39;NVoxels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The aseg.stats table contains 45 rows for the 45 brain structures:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">45</span>
</pre></div>
</div>
<p>Retrieve the data for all subjects, a 2D numpy array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s1">&#39;Left-Lateral-Ventricle&#39;</span> <span class="ow">in</span> <span class="n">column_data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_subjects_data</span> <span class="o">=</span> <span class="n">column_data</span><span class="p">[</span><span class="s1">&#39;Left-Lateral-Ventricle&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Let us find out the number of voxels for the left lateral ventricle of the first subject:</p>
<p>print(all_subjects_data[0])</p>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.extract_field_from_table_data">
<code class="descclassname">brainload.stats.</code><code class="descname">extract_field_from_table_data</code><span class="sig-paren">(</span><em>column_name</em>, <em>row_index</em>, <em>all_subjects_table_data_dict</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.extract_field_from_table_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the values in one table field for all subjects.</p>
<p>Extract the values in one table field, given by the column_name and row_index, for all subjects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>colum_name</strong> (<em>str</em>) – The name of the column that should be handled, i.e., the key in all_subjects_table_data_dict.  In combination with row_index, this defines the field that should be handled.</li>
<li><strong>row_index</strong> (<em>int</em>) – The index of the row that should be handled. In combination with column_name, this defines the field that should be handled. Note: you can use <code class="docutils literal notranslate"><span class="pre">`extract_table_data_indices_where`</span></code> to find the row index you want based on any value of any column.</li>
<li><strong>all_subjects_table_data_dict</strong> (<em>dict of str to numpy 2D array</em>) – Data as returned by the <code class="docutils literal notranslate"><span class="pre">`group_stats`</span></code> function.</li>
<li><strong>dtype</strong> (<em>numpy data type</em><em>, </em><em>optional</em>) – The data type of the returned numpy array. Defaults to <code class="docutils literal notranslate"><span class="pre">`numpy.float_`</span></code> if omitted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The data for all subjects, shape is (n, ) for n subjects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy 1D array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.extract_table_data_indices_where">
<code class="descclassname">brainload.stats.</code><code class="descname">extract_table_data_indices_where</code><span class="sig-paren">(</span><em>column_name</em>, <em>target_value_string</em>, <em>all_subjects_table_data_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.extract_table_data_indices_where" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the row index (or indices) in the table where the column column_name takes on the value target_value_string.</p>
<p>Find the row index (or indices) in the table where the column column_name takes on the value target_value_string. Typically you would chose a column and target value combinatin that is unique, leading to a single index (array of length 1). Note that this used the first entry (row) in the 2D matrix to read values: it is assumed that all entries are identical (since the data should come from equivalent stats files for all subjects).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>colum_name</strong> (<em>str</em>) – The name of the column that should be handled, i.e., the key in all_subjects_table_data_dict.  In combination with row_index, this defines the field that should be handled.</li>
<li><strong>target_value_string</strong> (<em>byte string</em>) – The value identifying the row you want. Note that this should be unique. If it is not, the returned list has length &gt; 1. Also note that the comparison happens before casting to dtype, so the value given here must be of type str. Note that this must a byte string, so in Python 3 you have to explicitely pass something like <code class="docutils literal notranslate"><span class="pre">`b'word_here'`</span></code>.</li>
<li><strong>all_subjects_table_data_dict</strong> (<em>dict of str to numpy 2D array</em>) – Data as returned by the <code class="docutils literal notranslate"><span class="pre">`group_stats`</span></code> function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The list of indices.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy 1D array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Find the index of the row where the value of the ‘StructName’ column is ‘Left-Amygdala’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">all_subjects_table_data_dict</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">group_stats_aseg</span><span class="p">([</span><span class="s1">&#39;subject1&#39;</span><span class="p">,</span> <span class="s1">&#39;subject2&#39;</span><span class="p">],</span> <span class="n">my_subjects_dir</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_indices</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">extract_table_data_indices_where</span><span class="p">(</span><span class="s1">&#39;StructName&#39;</span><span class="p">,</span> <span class="s1">&#39;Left-Amygdala&#39;</span><span class="p">,</span> <span class="n">all_subjects_table_data_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">row_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">12</span>        <span class="c1"># see aseg.stats table: amygdala is row 12</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.get_stats_table_column_names">
<code class="descclassname">brainload.stats.</code><code class="descname">get_stats_table_column_names</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>stats_file_name</em>, <em>subject='fsaverage'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.get_stats_table_column_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.stats.group_stats">
<code class="descclassname">brainload.stats.</code><code class="descname">group_stats</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em>, <em>stats_file_name</em>, <em>stats_table_type_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.group_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve stats for a group of subjects.</p>
<p>Retrieve stats for a group of subjects. The file may be for one hemisphere (files like lh.aparc.stats) or for the entire brain (like stats_table_type_list.stats). This function does not care about hemispheres, it parses a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_list</strong> (<em>list of str</em>) – List of subject identifiers (subjects in the subjects_dir).</li>
<li><strong>subjects_dir</strong> (<em>str</em>) – Subjects directory, as defined by the environment variable SUBJECTS_DIR for FreeSurfer.</li>
<li><strong>stats_file_name</strong> (<em>str</em>) – File name of the subjects file including file extension, relative to a subject’s <code class="docutils literal notranslate"><span class="pre">`stats`</span></code> directory. Example: ‘aseg.stats’.</li>
<li><strong>stats_table_type_list</strong> (<em>list of numpy types</em><em>, </em><em>optional.</em>) – A list defining the data types for the columns in the table contained in stats files. See the functions typelist_for_aseg_stats and typelist_for_aparc_atlas_stats for examples. If omitted, the table data will be returned as None. The measures data is unaffected.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>all_subjects_measures_dict</strong> (<em>dict of string to numpy 1D array.</em>) – The data from the measure rows in the files. Each key in the dictionary is the name of a measure, and the value is the data for all subjects in a numpy float array. The array shape is (n, ) for n subjects.</li>
<li><strong>all_subjects_table_data_dict</strong> (<em>dict of string to numpy 2D array</em>) – The data for all table columns in the files. Each key in the dictionary is the name of a column in the stats table, and the value is the data for all rows (i.e., atlas regions) for all subjects in a numpy 2D float array. The array shape is (n, m) for n subjects and a table with m rows. Note that the data type differs between the arrays and is defined by the argument <code class="docutils literal notranslate"><span class="pre">`stats_table_type_list`</span></code>. The colums include a string column that holds the region names, it is called ‘StructName’ for both aparc and aseg stats files.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#brainload.stats.typelist_for_aseg_stats" title="brainload.stats.typelist_for_aseg_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">typelist_for_aseg_stats()</span></code></a></dt>
<dd>pre-defined list of numpy data types for the files aseg.stats, can be used to pass stats_table_type_list</dd>
<dt><a class="reference internal" href="#brainload.stats.typelist_for_aparc_atlas_stats" title="brainload.stats.typelist_for_aparc_atlas_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">typelist_for_aparc_atlas_stats()</span></code></a></dt>
<dd>pre-defined list of numpy data types for the files lh.aparc.stats and rh.aparc.stats, can be used to pass stats_table_type_list</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.group_stats_aparc">
<code class="descclassname">brainload.stats.</code><code class="descname">group_stats_aparc</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em>, <em>hemi</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.group_stats_aparc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.stats.group_stats_aparc_DKTatlas">
<code class="descclassname">brainload.stats.</code><code class="descname">group_stats_aparc_DKTatlas</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em>, <em>hemi</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.group_stats_aparc_DKTatlas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.stats.group_stats_aparc_a2009s">
<code class="descclassname">brainload.stats.</code><code class="descname">group_stats_aparc_a2009s</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em>, <em>hemi</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.group_stats_aparc_a2009s" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.stats.group_stats_aseg">
<code class="descclassname">brainload.stats.</code><code class="descname">group_stats_aseg</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.group_stats_aseg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.stats.group_stats_by_row">
<code class="descclassname">brainload.stats.</code><code class="descname">group_stats_by_row</code><span class="sig-paren">(</span><em>subjects_list</em>, <em>subjects_dir</em>, <em>stats_file_name</em>, <em>stats_table_type_list=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.group_stats_by_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve stats for a group of subjects.</p>
<p>Retrieve stats for a group of subjects. The file may be for one hemisphere (files like lh.aparc.stats) or for the entire brain (like stats_table_type_list.stats). This function does not care about hemispheres, it parses a file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subjects_list</strong> (<em>list of str</em>) – List of subject identifiers (subjects in the subjects_dir).</li>
<li><strong>subjects_dir</strong> (<em>str</em>) – Subjects directory, as defined by the environment variable SUBJECTS_DIR for FreeSurfer.</li>
<li><strong>stats_file_name</strong> (<em>str</em>) – File name of the subjects file including file extension, relative to a subject’s <code class="docutils literal notranslate"><span class="pre">`stats`</span></code> directory. Example: ‘aseg.stats’.</li>
<li><strong>stats_table_type_list</strong> (<em>list of numpy types</em><em>, </em><em>optional.</em>) – A list defining the data types for the columns in the table contained in stats files. See the functions typelist_for_aseg_stats and typelist_for_aparc_atlas_stats for examples. If omitted, the table data will be returned as None. The measures data is unaffected.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>all_subjects_measures_dict</strong> (<em>dict of string to numpy 1D array.</em>) – The data from the measure rows in the files. Each key in the dictionary is the name of a measure, and the value is the data for all subjects in a numpy float array. The array shape is (n, ) for n subjects.</li>
<li><strong>all_subjects_table_data_dict_by_region</strong> (<em>dict of string to dict of string to numpy 2D array</em>) – The data for all table rows (regions) in the files. Each key in the dictionary is the name of a region (row, ‘StructName’ column entry in that row) in the stats table. Then the value is another dictionary, where the keys are subject IDs. The value is the data for all columns in the table for that subject. If a subject has no data on a region, it still has an entry, but all the values are NaNs.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#brainload.stats.typelist_for_aseg_stats" title="brainload.stats.typelist_for_aseg_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">typelist_for_aseg_stats()</span></code></a></dt>
<dd>pre-defined list of numpy data types for the files aseg.stats, can be used to pass stats_table_type_list</dd>
<dt><a class="reference internal" href="#brainload.stats.typelist_for_aparc_atlas_stats" title="brainload.stats.typelist_for_aparc_atlas_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">typelist_for_aparc_atlas_stats()</span></code></a></dt>
<dd>pre-defined list of numpy data types for the files lh.aparc.stats and rh.aparc.stats, can be used to pass stats_table_type_list</dd>
<dt><a class="reference internal" href="#brainload.annotations.get_atlas_region_names" title="brainload.annotations.get_atlas_region_names"><code class="xref py py-func docutils literal notranslate"><span class="pre">brainload.annotations.get_atlas_region_names()</span></code></a></dt>
<dd>get region names for an atlas/annotation</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.measures_to_numpy">
<code class="descclassname">brainload.stats.</code><code class="descname">measures_to_numpy</code><span class="sig-paren">(</span><em>measures</em>, <em>requested_measures=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.measures_to_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the measures list of lists to a 2D numpy array of the given type.</p>
<p>Convert the measures list of lists to a 2D numpy array of the given type. If only some of the measures are compatible with the type, you can give the names of all requested measures as a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>measures</strong> (<em>list of str lists</em>) – measures as returned by the stat() function: each element of the outer list represents a row in a stats file, and the inner string list contains the tokens of the line</li>
<li><strong>requested_measures</strong> (<em>list of string 2-tuples</em><em>, </em><em>optional</em>) – If given, only the measures listed in here are used. Each measure is identified by 2 strings, which must match the first and second token on the measure line. For a line like ‘# Measure Cortex, NumVert, Number of Vertices, 140843, unitless’, the 2 strings of a tuple would be ‘Cortex’ and ‘NumVert’. If omitted, all measures will be used.</li>
<li><strong>dtype</strong> (<em>numpy data type</em><em>, </em><em>optional</em>) – The data type that should be used for the returned numpy array. Defaults to <code class="docutils literal notranslate"><span class="pre">`np.float_`</span></code> if omitted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>measures_data</strong> (<em>numpy 1D array</em>) – The measure values, with the requested data type. The shape is (n, ) for n (requested) measures. The order is as given in the parameter measures. (If requested_measures is set, only those are included.)</li>
<li><strong>measure_names</strong> (<em>list of string 2-tuples</em>) – The names of the measures (same order as the data). The order is guaranteed to be identical to the order of measures in the input argument. (If requested_measures is set, only those are included.)</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.parse_curve_stats">
<code class="descclassname">brainload.stats.</code><code class="descname">parse_curve_stats</code><span class="sig-paren">(</span><em>subject_id</em>, <em>subjects_dir</em>, <em>hemi</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.parse_curve_stats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="brainload.stats.parse_curve_stats_file">
<code class="descclassname">brainload.stats.</code><code class="descname">parse_curve_stats_file</code><span class="sig-paren">(</span><em>curv_file</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.parse_curve_stats_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse curv.stats files.</p>
<p>Parse files stats/lh.curv.stats or stats/rh.curv.stats. Return all values and their names.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.register_dat_matrix">
<code class="descclassname">brainload.stats.</code><code class="descname">register_dat_matrix</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.register_dat_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the registration matrix from the given file.</p>
<p>Parse the registration matrix from the given file in register.dat file format. See <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/RegisterDat">https://surfer.nmr.mgh.harvard.edu/fswiki/RegisterDat</a> for the file format. The matrix encodes an affine transformation that can be applied to a coordinate vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_path</strong> (<em>str</em>) – Path to the file in register.dat format.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The parsed matrix, with dimension (4, 4).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array of floats</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Parse a register.dat file that comes with FreeSurfer v6.0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg_data_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">my_freesurfer_dir</span><span class="p">,</span> <span class="s1">&#39;subjects&#39;</span><span class="p">,</span> <span class="s1">&#39;cvs_avg35_inMNI152&#39;</span><span class="p">,</span> <span class="s1">&#39;mri.2mm&#39;</span><span class="p">,</span> <span class="s1">&#39;register.dat&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">register_dat_matrix</span><span class="p">(</span><span class="n">reg_data_file</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.stat">
<code class="descclassname">brainload.stats.</code><code class="descname">stat</code><span class="sig-paren">(</span><em>file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Read information from a FreeSurfer stats file.</p>
<p>Read information from a FreeSurfer stats file, e.g., <cite>subject/stats/lh.aparc.stats</cite> or <cite>aseg.stats</cite>. A stats file is a text file that contains a data table and various meta data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file_name</strong> (<em>string</em>) – The path to the stats file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>The result dictionary, containing the following 4 keys:</dt>
<dd><ul class="first last simple">
<li>’ignored_lines’: list of strings. The list of lines that were not parsed in a special way. This is raw data.</li>
<li>’measures’: string list of dimension (n, m) if there are n measures with m properties each stored in the stats file.</li>
<li>’table_data’: string list of dimension (i, j) when there are i lines containing j values each in the table stored in the stats file. You may want to convert the columns to the proper data types and put the result into several numpy arrays or a single Pandas data frame.</li>
<li>’table_column_headers’: string list. The names for the columns for the table_data. This information is parsed from the table_meta_data and given here for convenience.</li>
<li>’table_meta_data’: dictionary. The full table_meta_data. Stores properties in key, value sub dictionaries. For simple table properties, the dictionaries are keys of the returned dictionary. The only exception is the information on the table columns (header data). This information can be found under the key <cite>column_info_</cite>, which contains one dictionary for each column. In these dictionaries, data is stored as explained for simple table properties.</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">dictionary of strings (includes nested sub dicts)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Read the <cite>aseg.stats</cite> file for a subject:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="s1">&#39;/path/to/study/subject1/stats/aseg.stats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Collect some data, just to show the data structures.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;measures&#39;</span><span class="p">]))</span>    <span class="c1"># Will print the number of measures.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;measures&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1">#  Print all data on the first measure.</span>
</pre></div>
</div>
<p>Now lets print the table_data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_data_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_data&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_entries_per_row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>And get some information on the table columns (the table header):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_meta_data&#39;</span><span class="p">][</span><span class="s1">&#39;NTableCols&#39;</span><span class="p">]</span>   <span class="c1"># will print &quot;10&quot; (from a simple table property stored directly in the dictionary).</span>
</pre></div>
</div>
<p>Get the names of all the data columns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_column_headers&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Get the name of the first column:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">first_column_name</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_column_headers&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>More detailed information on the individual columns can be found under the special <cite>column_info_</cite> key if needed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">column2_info_dict</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;table_meta_data&#39;</span><span class="p">][</span><span class="s1">&#39;column_info_&#39;</span><span class="p">][</span><span class="s1">&#39;2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">column2_info_dict</span><span class="p">[</span><span class="s1">&#39;some_key&#39;</span><span class="p">])</span>          <span class="c1"># will print the value</span>
</pre></div>
</div>
<p>Note that all data is returned as string type, you will need to covert it to float (or whatever) yourself.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.stats_table_region_label_column_name">
<code class="descclassname">brainload.stats.</code><code class="descname">stats_table_region_label_column_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.stats_table_region_label_column_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the column that contains the region names for the table in stats files. The name is identical for all standard Freesurfer parcellation and segmentation stats files (aseg.stats, ?h.aparc.stats, ?h.aparc.a2009s.stats, and ?h.aparc.DKTatlas.stats), so the current version returns a fixed string.</p>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.stats_table_to_numpy">
<code class="descclassname">brainload.stats.</code><code class="descname">stats_table_to_numpy</code><span class="sig-paren">(</span><em>stat</em>, <em>type_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.stats_table_to_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Given types, convert the string matrix to a dictionary of numpy arrays (one for each table column).</p>
<p>Given types, convert the string matrix to a dictionary of numpy arrays (one for each table column). The stat dictionary is returned by the stat function, and you have to specify a list of numpy types, one for each column, to convert this. The type list is specific for the file that has been parsed, i.e., it differs between asge.stats and lh.aparc.stats. Determine it by looking at the file data. See the <cite>typelist_for_*</cite> functions in this module for pre-defined type lists for commonly parsed FreeSurfer stats files. Note that this function works by column, which is fine for a single subject, but may be problematic for group stats: the reason is that Freesurfer seems to omit regions from the stats file if the subject has no vertices which are assigned to that particular region. This means one cannot rely on all subjects having the same number of lines in the same stats file. It also means that if a subject does not contain the expected, full number of rows, the row number of a certain region differs by subject. This means parsing on a column-basis, like this function does it, does not work well for group stats. See the <code class="docutils literal notranslate"><span class="pre">`stats_table_to_numpy_by_row`</span></code> function for a solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stat</strong> (<em>dictionary</em>) – The data returned by the stat() function. Must contain the keys ‘table_data’ (2D list of strings, dimension n x m for n rows with m columns each) and ‘table_column_headers’ (1D list of m strings).</li>
<li><strong>type_list</strong> (<em>list of numpy types</em>) – List of numpy types with length m. Types must be listed in the order in which they should be applied to the columns.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dictionary of string</strong> – Each key is a column name, and each value is a numpy column array containing the typed data with shape (n, ) for n data rows in the table for the subject.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.stats_table_to_numpy_by_row">
<code class="descclassname">brainload.stats.</code><code class="descname">stats_table_to_numpy_by_row</code><span class="sig-paren">(</span><em>stat</em>, <em>type_list</em>, <em>subject_id</em>, <em>label_column_index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.stats_table_to_numpy_by_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Given types, convert the string matrix to a dictionary of numpy arrays (one for each table row, i.e., atlas region).</p>
<p>Given types, convert the string matrix to a dictionary of numpy arrays (one for each table row, i.e., atlas region).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stat</strong> (<em>dictionary</em>) – The data returned by the stat() function. Must contain the keys ‘table_data’ (2D list of strings, dimension n x m for n rows with m columns each) and ‘table_column_headers’ (1D list of m strings).</li>
<li><strong>type_list</strong> (<em>list of numpy types for columns</em>) – List of numpy types with length m. Types must be listed in the order in which they should be applied to the columns.</li>
<li><strong>subject_id</strong> (<em>string</em>) – The subject id for the data.</li>
<li><strong>label_column_index</strong> (<em>int</em><em>, </em><em>optional</em>) – The index of the label column, i.e., the column that contains the values to be used as the key in the returned dictionary. Usually the index of the column named ‘StructName’. Optional. Defaults to -1, which means that the first column of type string (according to the <code class="docutils literal notranslate"><span class="pre">`type_list`</span></code> argument) will be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dictionary of string</strong> – Each key is a row (i.e., atlas region) name, and each value is a numpy row array containing the data as np.floats with shape (n, ) for n data columns in the table for the subject. If the type of a column (as specified in the <code class="docutils literal notranslate"><span class="pre">`type_list`</span></code> argument) is NOT a subtype of np.number, the value is returned as NaN.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.typelist_for_aparc_atlas_stats">
<code class="descclassname">brainload.stats.</code><code class="descname">typelist_for_aparc_atlas_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.typelist_for_aparc_atlas_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine list of numpy data types for the table in an aparc atlas file.</p>
<p>Determine list of numpy data types for the table in an aparc atlas file. The type list is identical for the files <cite>?h.aparc.stats</cite>, <cite>?h.aparc.2009s.stats</cite>, and <cite>?h.aparc.DKTatlas.stats</cite>. The 10 columns in each file are: StructName NumVert SurfArea GrayVol ThickAvg ThickStd MeanCurv GausCurv FoldInd CurvInd</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of the proper numpy data types to use for each data column in the file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of numpy data types</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.stats.typelist_for_aseg_stats">
<code class="descclassname">brainload.stats.</code><code class="descname">typelist_for_aseg_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.stats.typelist_for_aseg_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine list of numpy data types for the table in an <cite>aseg.stats</cite> file.</p>
<p>Determine list of numpy data types for the table in an <cite>aseg.stats</cite> file. The 10 columns in this file are: Index SegId NVoxels Volume_mm3 StructName normMean normStdDev normMin normMax normRange.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of the proper numpy data types to use for each data column in the file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of numpy data types</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-brainload.surfacegraph">
<span id="brainload-surfacegraph-module"></span><h2>brainload.surfacegraph module<a class="headerlink" href="#module-brainload.surfacegraph" title="Permalink to this headline">¶</a></h2>
<p>Turn a surface mesh into a networkx graph. Useful for asking questions that can be answered using graph algorithms. An example would be to find, for a given source vertex, all vertices which are connected to it by a certain number of hops. Requires networkx.</p>
<dl class="class">
<dt id="brainload.surfacegraph.SurfaceGraph">
<em class="property">class </em><code class="descclassname">brainload.surfacegraph.</code><code class="descname">SurfaceGraph</code><span class="sig-paren">(</span><em>verts</em>, <em>faces</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.surfacegraph.SurfaceGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A graph representing the vertices and edges of a brain surface mesh.</p>
<dl class="method">
<dt id="brainload.surfacegraph.SurfaceGraph.get_neighbors_up_to_dist">
<code class="descname">get_neighbors_up_to_dist</code><span class="sig-paren">(</span><em>source_vert</em>, <em>dist</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.surfacegraph.SurfaceGraph.get_neighbors_up_to_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all neighbors up to graph distance dist away.</p>
<p>Get all neighbors up to graph distance dist away. Note that dist is the number of edges to traverse in the graph to get from the source to the vertex. (It is NOT Euclidian distance.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_vert</strong> (<em>int</em>) – Index of the source vertex.</li>
<li><strong>dist</strong> (<em>The distance up until which neighbors should be returned. This is the number of edges to traverse in the graph</em><em> (</em><em>along a shortest path of length dist from source to the respective neighbor</em><em>)</em><em></em>) – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>neighbors</strong> – The indices of all vertices which lie within distance dist of the source_vert.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainload.braindescriptors">
<span id="brainload-braindescriptors-module"></span><h2>brainload.braindescriptors module<a class="headerlink" href="#module-brainload.braindescriptors" title="Permalink to this headline">¶</a></h2>
<p>Collect various brain descriptors.</p>
<p>Functions to collect brain descriptors from neuroimaging data preprocessed with FreeSurfer.</p>
<dl class="class">
<dt id="brainload.braindescriptors.BrainDescriptors">
<em class="property">class </em><code class="descclassname">brainload.braindescriptors.</code><code class="descname">BrainDescriptors</code><span class="sig-paren">(</span><em>subjects_dir</em>, <em>subjects_list</em>, <em>hemi='both'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Collects brain descriptors for one or more subjects.</p>
<p>This class can parse all standard statistics files which are written by FreeSurfer when a subject is preprocessed using the recon-all pipeline. This includes
brain segmentation stats (volume-based, like the <code class="docutils literal notranslate"><span class="pre">`stats/aseg.stats`</span></code> file), brain parcellation stats (surface-based, like <code class="docutils literal notranslate"><span class="pre">`?h.aparc.a2009s.stats`</span></code>) and special stats file like the <code class="docutils literal notranslate"><span class="pre">`curv.stats`</span></code> files.</p>
<p>It can also compute stats based on a parcellation atlas and any custom morphometry measure that you may have computed (e.g., local gyrifiaction index or some arbitrary vertex-wise measure you have computed yourself).</p>
<p>You can export the resulting data to a CSV file so you can load them in your favorite statistical software later. (No, I did not mention AI.) If that favorite software happens to be python, you can just access the <code class="docutils literal notranslate"><span class="pre">`descriptor_names`</span></code> and <code class="docutils literal notranslate"><span class="pre">`descriptor_values`</span></code> properties of the class instead.</p>
<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.add_curv_stats">
<code class="descname">add_curv_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.add_curv_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Add surface curvature stats.</p>
<p>Add brain surface curvature stats. This add the data from the <code class="docutils literal notranslate"><span class="pre">`stats/?h.curv.stats`</span></code> files.</p>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.add_custom_measure_stats">
<code class="descname">add_custom_measure_stats</code><span class="sig-paren">(</span><em>atlas_list</em>, <em>measure_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.add_custom_measure_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Add custom stats for a measure and atlas.</p>
<p>Add custom stats for a measure and atlas. E.g., compute descriptive stats (min, max, mean, …) for a measure like ‘pial_lgi’ in all regions of an atlas like ‘aparc’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>atlas_list</strong> (<em>list of string</em>) – Each entry should be a valid FreeSurfer segmentation name, like <code class="docutils literal notranslate"><span class="pre">`aseg`</span></code>. A file with that name has to exist in the subjects directory under <code class="docutils literal notranslate"><span class="pre">`stats/`</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">`stats/aseg.stats`</span></code> for <code class="docutils literal notranslate"><span class="pre">`aseg`</span></code>.</li>
<li><strong>measure_list</strong> (<em>list of string</em>) – A list of vertex-wise morphometry measurements, like <code class="docutils literal notranslate"><span class="pre">`volume`</span></code>, <code class="docutils literal notranslate"><span class="pre">`thickness`</span></code>, or <code class="docutils literal notranslate"><span class="pre">`area`</span></code>. A hemisphere-dependent file with that name has to exist in the subjects directory under <code class="docutils literal notranslate"><span class="pre">`surf/`</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">`surf/lh.area`</span></code> and <code class="docutils literal notranslate"><span class="pre">`surf/rh.area`</span></code> for the two hemispheres is the given string is <code class="docutils literal notranslate"><span class="pre">`area`</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.add_parcellation_stats">
<code class="descname">add_parcellation_stats</code><span class="sig-paren">(</span><em>atlas_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.add_parcellation_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Add brain parcellation stats.</p>
<p>Add brain parcellation stats for a list of atlases, i.e., annotation files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>atlas_list</strong> (<em>list of strings</em>) – The atlas names. E.g., <code class="docutils literal notranslate"><span class="pre">`['aparc',</span> <span class="pre">'aparc.a2009s']`</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.add_segmentation_stats">
<code class="descname">add_segmentation_stats</code><span class="sig-paren">(</span><em>segmentation_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.add_segmentation_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Add brain parcellation stats.</p>
<p>Add brain parcellation stats. This add the data from the stats/aseg.stats file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>segmentation_list</strong> (<em>list of string</em>) – Each entry should be a valid FreeSurfer segmentation name, like <code class="docutils literal notranslate"><span class="pre">`aseg`</span></code>. A file with that name has to exist in the subjects directory under <code class="docutils literal notranslate"><span class="pre">`stats/`</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">`stats/aseg.stats`</span></code> for <code class="docutils literal notranslate"><span class="pre">`aseg`</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.add_single_segmentation_stats">
<code class="descname">add_single_segmentation_stats</code><span class="sig-paren">(</span><em>atlas</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.add_single_segmentation_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Add brain parcellation stats.</p>
<p>Add brain parcellation stats. This add the data from the stats/aseg.stats file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>atlas</strong> (<em>string</em>) – A valid FreeSurfer segmentation name, like <code class="docutils literal notranslate"><span class="pre">`aseg`</span></code>. A file with that name has to exist in the subjects directory under <code class="docutils literal notranslate"><span class="pre">`stats/`</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">`stats/aseg.stats`</span></code> for <code class="docutils literal notranslate"><span class="pre">`aseg`</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.add_standard_stats">
<code class="descname">add_standard_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.add_standard_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to add all descriptors which are computed by default when running Freesurfer v6 recon-all on a subject.</p>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_NaNs">
<code class="descname">check_for_NaNs</code><span class="sig-paren">(</span><em>threshold=0.6</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_NaNs" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for descriptors and subjects with all NaN values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>threshold</strong> (<em>float</em>) – The NaN threshold, subjects and descriptors for which the share of NaN values exceeds this threshold are reported. Must be between .0 and 1.0 to make sense. Defaults to 0.6.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>subjects_over_threshold</strong> (<em>list of string</em>) – The subjects</li>
<li><strong>descriptors_over_threshold</strong> (<em>list of string</em>) – The descriptors</li>
<li><strong>nan_share_per_subject</strong> (<em>numpy float array</em>) – The share of NaN values for each subject. Numpy array with length n for the n subjects.</li>
<li><strong>nan_share_per_descriptor</strong> (<em>numpy float array</em>) – The share of NaN values for each descriptor. Numpy array with length m for the m descriptor.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_curv_stats_files">
<code class="descname">check_for_curv_stats_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_curv_stats_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_custom_measure_stats_files">
<code class="descname">check_for_custom_measure_stats_files</code><span class="sig-paren">(</span><em>annot_list</em>, <em>morph_list</em>, <em>morph_file_format='curv'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_custom_measure_stats_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for custom annotation files.</p>
<p>Check for the existence of custom annotation and morphometry files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>annot_list</strong> (<em>list of strings</em>) – The annotations (atlas file names), a typical entry in the list would be “aparc” or “aparc.a2009s”.</li>
<li><strong>morph_list</strong> (<em>list of strings</em>) – The morphometry data, a typical entry in the list would be “area” or “thickness”.</li>
<li><strong>morph_file_format</strong> (<em>string</em><em>, </em><em>one of 'curv'</em><em>, </em><em>'mgh'</em><em>, or </em><em>'mgz'. Defaults to 'curv'.</em>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_hemi_dependent_file">
<code class="descname">check_for_hemi_dependent_file</code><span class="sig-paren">(</span><em>parts</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_hemi_dependent_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for hemi-dependent file.</p>
<p>Check for the existence of a file that has an lh and an rh version.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parts</strong> (<em>list of strings</em>) – Path to file, relative to the subject’s directory. The last list element should be the file name (all other ones are directories). The last element must NOT contain the prefix “lh.” or “rh.”, as these will be added automatically.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_hemi_independent_file">
<code class="descname">check_for_hemi_independent_file</code><span class="sig-paren">(</span><em>parts</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_hemi_independent_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_parcellation_stats_files">
<code class="descname">check_for_parcellation_stats_files</code><span class="sig-paren">(</span><em>atlas_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_parcellation_stats_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.check_for_segmentation_stats_files">
<code class="descname">check_for_segmentation_stats_files</code><span class="sig-paren">(</span><em>segmentation_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.check_for_segmentation_stats_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.report_descriptors">
<code class="descname">report_descriptors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.report_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>Print some information on descriptors to stdout.</p>
</dd></dl>

<dl class="method">
<dt id="brainload.braindescriptors.BrainDescriptors.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>stats_file</em>, <em>subjects_file=None</em>, <em>delim='</em>, <em>'</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.braindescriptors.BrainDescriptors.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the descriptors to files.</p>
<p>Save the descriptors to text files in CSV format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stats_file</strong> (<em>string</em>) – Path and file name for the CSV file that will hold the descriptor data.</li>
<li><strong>subjects_file</strong> (<em>string</em><em>, </em><em>optional</em>) – Path a filename of a text file. If given, the subject IDs will be written to this file, one per line. The order of the subjects matches the order of the data in the stats_file.</li>
<li><strong>delim</strong> (<em>str</em>) – Delimiter for stats_file, defaults to “,”.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;braindescriptors.csv&quot;</span><span class="p">,</span> <span class="n">subjects_file</span><span class="o">=</span><span class="s2">&quot;subjects.txt&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainload.spatial">
<span id="brainload-spatial-module"></span><h2>brainload.spatial module<a class="headerlink" href="#module-brainload.spatial" title="Permalink to this headline">¶</a></h2>
<p>Simple functions for spatial tranformation of 3-dimensional coordinates.</p>
<p>These functions are helpful if you want to rotate, translate, mirror, or scale (brain) meshes. In general, you would use them roughly like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload</span> <span class="k">as</span> <span class="nn">bl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vert_coords</span><span class="p">,</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">subject</span><span class="p">(</span><span class="s1">&#39;bert&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">coords_a2s</span><span class="p">(</span><span class="n">vert_coords</span><span class="p">)</span>
</pre></div>
</div>
<p>Now you have the coordinates of the mesh vertices in the required format and can call any function from this module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">zt</span> <span class="o">=</span> <span class="n">bl</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">translate_3D_coordinates_along_axes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># or some other function</span>
</pre></div>
</div>
<dl class="function">
<dt id="brainload.spatial.apply_affine">
<code class="descclassname">brainload.spatial.</code><code class="descname">apply_affine</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>k</em>, <em>affine_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.apply_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an affine matrix to the given coordinates. The affine matrix consists of a 3x3 rotation matrix and a 3x1 transposition matrix (plus the last row).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>j</strong><strong>, </strong><strong>k</strong> (<em>i</em><em>,</em>) – The source coordinates.</li>
<li><strong>affine_matrix</strong> (<em>numpy 2D float array with shape</em><em> (</em><em>4</em><em>, </em><em>4</em><em>)</em>) – The affine matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The coordinate vector after applying the matrix. A 1D array (vector) of shape (3, ) if the inputs were scalar, a 2D array with shape (n, 3) otherwise, were n is the length of the input array-likes.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">`apply_affine_3D`</span></code> can handle a 2D matrix of coordinates, e.g., with shape (n, 3) for n 3D coordinates.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.apply_affine_3D">
<code class="descclassname">brainload.spatial.</code><code class="descname">apply_affine_3D</code><span class="sig-paren">(</span><em>coords_3d</em>, <em>affine_matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.apply_affine_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an affine transformation to all coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coords_3d</strong> (<em>numpy 2D array</em>) – The source coordinates, given as a 2D numpy array with shape (n, 3). Each of the n rows represents a point in space, given by its x, y and z coordinates.</li>
<li><strong>affine_matrix</strong> (<em>numpy 2D float array with shape</em><em> (</em><em>4</em><em>, </em><em>4</em><em>)</em>) – The affine matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The coordinates after applying the matrix, 2D numpy array with shape (n, 3) Same shape as the input coords.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.coords_a2s">
<code class="descclassname">brainload.spatial.</code><code class="descname">coords_a2s</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.coords_a2s" title="Permalink to this definition">¶</a></dt>
<dd><p>Split single array for all 3 coords into 3 separate ones.</p>
<p>Split a 2D array with shape (3, n) of coordinates (x, y, z values) into 3 separate 1D arrays of length n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> (<em>Numpy 2D array of numbers</em>) – The merged coordinate array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Has the same length as the <cite>y</cite> and <cite>z</cite> arrays.</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Has the same length as the <cite>x</cite> and <cite>z</cite> arrays.</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Has the same length as the <cite>x</cite> and <cite>y</cite> arrays.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">coords_a2s</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.coords_s2a">
<code class="descclassname">brainload.spatial.</code><code class="descname">coords_s2a</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.coords_s2a" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a single xyz coordinate array into x, y and z arrays.</p>
<p>Merge 3 arrays of length n with coordinates (x, y, z values) into a single 2D coordinate array of shape (3, n).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Must have the same length as the <cite>y</cite> and <cite>z</cite> arrays.</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Must have the same length as the <cite>x</cite> and <cite>z</cite> arrays.</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Must have the same length as the <cite>x</cite> and <cite>y</cite> arrays.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The merged coordinate array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Numpy 2D array of numbers</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">coords_s2a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.deg2rad">
<code class="descclassname">brainload.spatial.</code><code class="descname">deg2rad</code><span class="sig-paren">(</span><em>degrees</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.deg2rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an angle given in degrees to radians.</p>
<p>Convert an angle given in degrees to radians. 360 degrees are 2 Pi radians. If negative values or values larger than 360 are passed, use the modulo operation to bring them to a suitable range first. In other words, passing -90 will be transformed to 360 - 90 = 270 degrees, and will thus return 1.5 Pi radians.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>degrees</strong> (<em>float</em>) – The angle in degrees.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The angle in radians.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rad</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">180</span><span class="p">)</span>   <span class="c1"># will be Pi</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_affine_matrix_MNI152_to_MNI305">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_affine_matrix_MNI152_to_MNI305</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_affine_matrix_MNI152_to_MNI305" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the transformation matrix from MNI152 sapce to fsaverage space (=MNI305 space).</p>
<p>This is the inverse of the MNI305 to MNI152 matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The affine transformation matrix, a float matrix with shape (4, 4).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_affine_matrix_MNI305_to_MNI152">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_affine_matrix_MNI305_to_MNI152</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_affine_matrix_MNI305_to_MNI152" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the transformation matrix from fsaverage space (=MNI305 space) to MNI152 space.</p>
<p>Get the transformation matrix from fsaverage space (=MNI305 space) to MNI152 space. This matrix was retrieved from <a class="reference external" href="http://freesurfer.net/fswiki/CoordinateSystems">http://freesurfer.net/fswiki/CoordinateSystems</a>, see use case 8 at the very bottom of the page.
Quoting the linked page: ‘The above matrix is V152*inv(T152)*R*T305*inv(V305), where V152 and V305 are the vox2ras matrices from the 152 and 305 spaces, T152 and T305 are the tkregister-vox2ras matrices from the 152 and 305 spaces, and R is from $FREESURFER_HOME/average/mni152.register.dat’</p>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_equivalent_voxel_of_raw_volume_in_conformed_volume">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_equivalent_voxel_of_raw_volume_in_conformed_volume</code><span class="sig-paren">(</span><em>raw_volume_file</em>, <em>conformed_volume_file</em>, <em>raw_volume_query_voxels_crs</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_equivalent_voxel_of_raw_volume_in_conformed_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the position of a voxel in the conformed volume.</p>
<p>Find the voxel CRS in the conformed volume that is equivalent to the query voxel CRS in the raw volume. Note that this always returns a single voxel for a query voxel. It does not compute all voxel that may represent the source voxel (e.g., if the voxel size is much smaller in the destination volume). Note that this function also works in reverse (simply exchange the order of the 2 volumes and give query voxels in the first one). In fact, it will work between any pair of volume files as long as they within the same space (i.e., the RAS coordinates of the same spot in both files are identical). The function works based on the vox2ras matrix in the source file and the ras2vox matrix in the destination file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_volume_file</strong> (<em>string</em>) – Path to the raw volume, i.e., the volume that has not yet been processed using FreeSurfer. You could also use <code class="docutils literal notranslate"><span class="pre">`rawavg.mgz`</span></code> in the <code class="docutils literal notranslate"><span class="pre">`mri`</span></code> sub directory of a subject. Must be in mgh or mgz format. You can use the <code class="docutils literal notranslate"><span class="pre">`mri_convert`</span></code> binary that comes with FreeSurfer to convert from nifti to mgz.</li>
<li><strong>conformed_volume_file</strong> (<em>string</em>) – Path to a conformed volume, i.e., a volume that has been conformed to 256x256x256 voxels with 1mm^3 voxel volume. This applies to all subject volumes in the <code class="docutils literal notranslate"><span class="pre">`mri`</span></code> directory of a subject, e.g., <code class="docutils literal notranslate"><span class="pre">`brain.mgz`</span></code> or <code class="docutils literal notranslate"><span class="pre">`orig.mgz`</span></code>. Must be in mgh or mgz format. You can use the <code class="docutils literal notranslate"><span class="pre">`mri_convert`</span></code> binary that comes with FreeSurfer to convert from nifti to mgz. Hint: You can create a conformed version from a raw volume using the <code class="docutils literal notranslate"><span class="pre">`--conform`</span></code> option of <code class="docutils literal notranslate"><span class="pre">`mri_convert`</span></code>.</li>
<li><strong>raw_volume_query_voxels_crs</strong> (<em>numpy 2D array of int</em>) – The column, row, slice indices of the query voxels in the raw volume. The array must have dimension (n, 3) for n query voxels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>conf_volume_voxels_crs</strong> – The column, row, slice indices of the query voxels in the conformed volume. The array has dimension (n, 3) for n query voxels.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy 2D array of int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_freesurfer_matrix_ras2vox">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_freesurfer_matrix_ras2vox</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_freesurfer_matrix_ras2vox" title="Permalink to this definition">¶</a></dt>
<dd><p>Get standard matrix to convert RAS coordinate to voxel index for Freesurfer conformed space volumes.</p>
<p>Get matrix to convert RAS coordinate to voxel index for Freesurfer conformed space volumes. See the documentation for get_freesurfer_matrix_vox2ras for background information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The affine transformation matrix, a float matrix with shape (4, 4).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_freesurfer_matrix_vox2ras">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_freesurfer_matrix_vox2ras</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_freesurfer_matrix_vox2ras" title="Permalink to this definition">¶</a></dt>
<dd><p>The FreeSurfer vox2ras matrix, this is identical to the vox2ras-tkr matrix.</p>
<dl class="docutils">
<dt>Retrieved from <a class="reference external" href="http://freesurfer.net/fswiki/CoordinateSystems">http://freesurfer.net/fswiki/CoordinateSystems</a>, use case 4. Note that fsaverage is in MNI305 space. Generated by running: <cite>mri_info –vox2ras-tkr $FREESURFER_HOME/subjects/fsaverage/mri/orig.mgz</cite>. See also <a class="reference external" href="http://eeg.sourceforge.net/doc_m2html/bioelectromagnetism/freesurfer_surf2voxels.html">http://eeg.sourceforge.net/doc_m2html/bioelectromagnetism/freesurfer_surf2voxels.html</a>. Quoting from that page: ‘FreeSurfer MRI volumes are 256^3 voxels, 1mm^3 each. The MRI volume index has an origin at the left, posterior, inferior voxel, such that:</dt>
<dd><ul class="first last simple">
<li>Sagital increases from left to right (+X Right)</li>
<li>Coronal increases from posterior to anterior (+Y Anterior)</li>
<li>Axial   increases from inferior to superior (+Z Superior).</li>
</ul>
</dd>
</dl>
<p>The MRI RAS values have an origin at the middle of the volume, in approximately voxel 128, 128, 128.’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The affine transformation matrix, a float matrix with shape (4, 4).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_n_neighborhood_indices_3D">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_n_neighborhood_indices_3D</code><span class="sig-paren">(</span><em>volume_shape</em>, <em>point</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_n_neighborhood_indices_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the indices of the n-neighborhood of the point within the volume.</p>
<p>Compute the indices of the square n-neighborhood of the point within the volume, including the point itself. This function returns only valid indices in the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume_shape</strong> (<em>3-tuple of int</em>) – The shape of the volume (e.g., whole 3D image)</li>
<li><strong>point</strong> (<em>1D array of length 3</em>) – The x, y, and z coordinates of the query point. Must lie within the volume. This is the point around which the neighborhood will be computed.</li>
<li><strong>n</strong> (<em>int &gt;= 0</em>) – The neighborhood size (in every direction, the neighborhood is always square). For 0, only the index of the point itself will be returned. For 1, the 26 neighbors in distance 1 plus the index of the point itself (so 27 indices) will be returned. If the point is close to the border of the volume, only the valid subset will be returned of course. For n=2 you get (up to) 125 indices.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>indices</strong> – The 3 arrays have identical size and contain the x, y, and z indices of the neighborhood.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple of 3 numpy 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_n_neighborhood_indices_3D</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_n_neighborhood_indices_3D_points">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_n_neighborhood_indices_3D_points</code><span class="sig-paren">(</span><em>volume_shape</em>, <em>points</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_n_neighborhood_indices_3D_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the indices of the n-neighborhood of the point within the volume.</p>
<p>Compute the indices of the square n-neighborhood of the point within the volume, including the point itself. This function returns only valid indices in the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume_shape</strong> (<em>3-tuple of int</em>) – The shape of the volume (e.g., whole 3D image)</li>
<li><strong>points</strong> (<em>2D array of shape</em><em> (</em><em>n</em><em>, </em><em>3</em><em>) </em><em>for n points</em>) – The x, y, and z coordinates of the query points. Must lie within the volume. These are the points around which the neighborhoods will be computed.</li>
<li><strong>n</strong> (<em>int &gt;= 0</em>) – The neighborhood size (in every direction, the neighborhood is always square). For 0, only the index of the point itself will be returned. For 1, the 26 neighbors in distance 1 plus the index of the point itself (so 27 indices) will be returned. If the point is close to the border of the volume, only the valid subset will be returned of course. For n=2 you get (up to) 125 indices.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>indices</strong> – The 3 arrays have identical size and contain the x, y, and z indices of the neighborhood.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple of 3 numpy 1D arrays</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_n_neighborhood_indices_3D_points</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_n_neighborhood_start_stop_indices_3D">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_n_neighborhood_start_stop_indices_3D</code><span class="sig-paren">(</span><em>volume_shape</em>, <em>point</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_n_neighborhood_start_stop_indices_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the start and stop indices along the 3 dimensions for the n-neighborhood of the point within the 3D volume.</p>
<p>Note that this returns an index range where the end is <em>non-inclusive</em>! So for a point at x,y,z with 0-neighborhood (only the point itself), you will get x,x+1,y,y+1,z,z+1 as return values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume_shape</strong> (<em>3-tuple of int</em>) – The shape of the volume (e.g., whole 3D image)</li>
<li><strong>point</strong> (<em>1D array of length 3</em>) – The x, y, and z coordinates of the query point. Must lie within the volume. This is the point around which the neighborhood will be computed.</li>
<li><strong>n</strong> (<em>int &gt;= 0</em>) – The neighborhood size (in every direction, the neighborhood is always square). For 0, only the index of the point itself will be returned. For 1, the 26 neighbors in distance 1 plus the index of the point itself (so 27 indices) will be returned. If the point is close to the border of the volume, only the valid subset will be returned of course. For n=2 you get (up to) 125 indices.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>xstart</strong> (<em>int</em>) – The x start index, inclusive.</li>
<li><strong>xend</strong> (<em>int</em>) – The x end index, exclusive.</li>
<li><strong>ystart</strong> (<em>int</em>) – The y start index, inclusive.</li>
<li><strong>yend</strong> (<em>int</em>) – The y end index, exclusive.</li>
<li><strong>zstart</strong> (<em>int</em>) – The z start index, inclusive.</li>
<li><strong>zend</strong> (<em>int</em>) – The z end index, exclusive.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xstart</span><span class="p">,</span> <span class="n">xend</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">yend</span><span class="p">,</span> <span class="n">zstart</span><span class="p">,</span> <span class="n">zend</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_n_neighborhood_start_stop_indices_3D</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1"># 1-neighborhood</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.get_n_neighborhood_start_stop_indices_3D_points">
<code class="descclassname">brainload.spatial.</code><code class="descname">get_n_neighborhood_start_stop_indices_3D_points</code><span class="sig-paren">(</span><em>volume_shape</em>, <em>points</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.get_n_neighborhood_start_stop_indices_3D_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the start and stop indices along the 3 dimensions for the n-neighborhood of the points within the 3D volume.</p>
<p>Note that this returns an index range where the end is <em>non-inclusive</em>! So for a point at x,y,z with 0-neighborhood (only the point itself), you will get x,x+1,y,y+1,z,z+1 as return values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume_shape</strong> (<em>3-tuple of int</em>) – The shape of the volume (e.g., whole 3D image)</li>
<li><strong>points</strong> (<em>2D array of shape</em><em> (</em><em>n</em><em>, </em><em>3</em><em>) </em><em>for n points</em>) – The x, y, and z coordinates of the query points. Must lie within the volume. These are the points around which the neighborhoods will be computed.</li>
<li><strong>n</strong> (<em>int &gt;= 0</em>) – The neighborhood size (in every direction, the neighborhood is always square). For 0, only the index of the point itself will be returned. For 1, the 26 neighbors in distance 1 plus the index of the point itself (so 27 indices) will be returned. If the point is close to the border of the volume, only the valid subset will be returned of course. For n=2 you get (up to) 125 indices.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>xstart</strong> (<em>1D numpy int array</em>) – The x start indices, inclusive.</li>
<li><strong>xend</strong> (<em>1D numpy int array</em>) – The x end indices, exclusive.</li>
<li><strong>ystart</strong> (<em>1D numpy int array</em>) – The y start indices, inclusive.</li>
<li><strong>yend</strong> (<em>1D numpy int array</em>) – The y end indices, exclusive.</li>
<li><strong>zstart</strong> (<em>1D numpy int array</em>) – The z start indices, inclusive.</li>
<li><strong>zend</strong> (<em>1D numpy int array</em>) – The z end indices, exclusive.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xstart</span><span class="p">,</span> <span class="n">xend</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">yend</span><span class="p">,</span> <span class="n">zstart</span><span class="p">,</span> <span class="n">zend</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_n_neighborhood_start_stop_indices_3D_points</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1"># 1-neighborhood</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.mirror_3D_coordinates_at_axis">
<code class="descclassname">brainload.spatial.</code><code class="descname">mirror_3D_coordinates_at_axis</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>axis</em>, <em>mirror_at_axis_coordinate=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.mirror_3D_coordinates_at_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror the given 3D coordinates on the given mirror plane.</p>
<p>Mirror or reflect the given 3D coordinates on a plane (perpendicular to the axis) at axis coordinate <cite>mirror_at_axis_coordinate</cite> at the given axis. If <cite>mirror_at_axis_coordinate</cite> is not given, the smallest coordinate along the mirror axis in the data is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Must have the same length as the <cite>y</cite> and <cite>z</cite> arrays.</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Must have the same length as the <cite>x</cite> and <cite>z</cite> arrays.</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Must have the same length as the <cite>x</cite> and <cite>y</cite> arrays.</li>
<li><strong>axis</strong> (<em>string</em><em>, </em><em>one of {'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'}</em>) – An axis identifier.</li>
<li><strong>mirror_at_axis_coordinate</strong> (<em>number | None</em>) – The coordinate along the axis <cite>axis</cite> at which the mirror plane should be created. If you set <cite>axis</cite> to ‘x’ and specify <cite>5</cite> for this, a yz-plane will be used at x coordinate 5. If not given, it defaults to the minimal axis coordinate for the respective axis in the data.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>x_mirrored</strong> (<em>Numpy array of numbers</em>) – The mirrored x coordinates.</li>
<li><strong>y_mirrored</strong> (<em>Numpy array of numbers</em>) – The mirrored y coordinates.</li>
<li><strong>z_mirrored</strong> (<em>Numpy array of numbers</em>) – The mirrored z coordinates.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Mirror at the origin of the x axis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">,</span> <span class="n">zm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">mirror_3D_coordinates_at_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ym</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>     <span class="c1"># -5 7 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ym</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zm</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># -6 8 10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.parse_registration_matrix">
<code class="descclassname">brainload.spatial.</code><code class="descname">parse_registration_matrix</code><span class="sig-paren">(</span><em>matrix_lines</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.parse_registration_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a registration matrix.</p>
<p>Parse a registration matrix from the 4 lines representing it in a register.dat file. See <a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/fswiki/RegisterDat">https://surfer.nmr.mgh.harvard.edu/fswiki/RegisterDat</a> for the file format. This function expects only the 4 matrix lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>matrix_lines</strong> (<em>list of str</em>) – The 4 matrix lines of a file in register.dat format. Each line muyt contain 4 floats, separated by spaces.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The parsed matrix, with dimension (4, 4).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">2D numpy array of floats</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.point_mirror_3D_coordinates">
<code class="descclassname">brainload.spatial.</code><code class="descname">point_mirror_3D_coordinates</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>point_x</em>, <em>point_y</em>, <em>point_z</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.point_mirror_3D_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Point-mirror or reflect the given coordinates at the given point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Must have the same length as the <cite>y</cite> and <cite>z</cite> arrays.</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Must have the same length as the <cite>x</cite> and <cite>z</cite> arrays.</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Must have the same length as the <cite>x</cite> and <cite>y</cite> arrays.</li>
<li><strong>point_x</strong> (<em>number</em>) – The x coordinate of the point used for mirroring.</li>
<li><strong>point_y</strong> (<em>number</em>) – The y coordinate of the point used for mirroring.</li>
<li><strong>point_z</strong> (<em>number</em>) – The z coordinate of the point used for mirroring.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>xm</strong> (<em>Numpy array of numbers</em>) – The mirrored x coordinates.</li>
<li><strong>ym</strong> (<em>Numpy array of numbers</em>) – The mirrored y coordinates.</li>
<li><strong>zm</strong> (<em>Numpy array of numbers</em>) – The mirrored z coordinates.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Mirror at the origin:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">,</span> <span class="n">zm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">point_mirror_3D_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ym</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>     <span class="c1"># -5 -7 -9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xm</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ym</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zm</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># -6 -8 -10</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.rad2deg">
<code class="descclassname">brainload.spatial.</code><code class="descname">rad2deg</code><span class="sig-paren">(</span><em>rad</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.rad2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an angle given in radians to degrees.</p>
<p>Convert an angle given in radians to degrees. 2 Pi radians are 360 degrees. If negative values or values larger than 2 Pi are passed, use the modulo operation to bring them to a suitable range first. In other words, passing -0.5 * Pi will be transformed to 2 - 0.5 = 1.5 Pi, and will thus return 270 degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rad</strong> (<em>float</em>) – The angle in radians.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The angle in degrees.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deg</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>   <span class="c1"># will be 360</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.rotate_3D_coordinates_around_axes">
<code class="descclassname">brainload.spatial.</code><code class="descname">rotate_3D_coordinates_around_axes</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>radians_x</em>, <em>radians_y</em>, <em>radians_z</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.rotate_3D_coordinates_around_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate coordinates around the 3 axes.</p>
<p>Rotate coordinates around the x, y, and z axes. The rotation values must be given in radians.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Must have the same length as the <cite>y</cite> and <cite>z</cite> arrays. (See <cite>coords_a2s</cite> if you have a single 2D array containing all 3.)</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Must have the same length as the <cite>x</cite> and <cite>z</cite> arrays. (See <cite>coords_a2s</cite> if you have a single 2D array containing all 3.)</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Must have the same length as the <cite>x</cite> and <cite>y</cite> arrays. (See <cite>coords_a2s</cite> if you have a single 2D array containing all 3.)</li>
<li><strong>radians_x</strong> (<em>number</em>) – A single number, representing the rotation in radians around the x axis.</li>
<li><strong>radians_y</strong> (<em>number</em>) – A single number, representing the rotation in radians around the y axis.</li>
<li><strong>radians_z</strong> (<em>number</em>) – A single number, representing the rotation in radians around the z axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>xr</strong> (<em>Numpy array of numbers</em>) – The rotated x coordinates.</li>
<li><strong>yr</strong> (<em>Numpy array of numbers</em>) – The rotated y coordinates.</li>
<li><strong>zr</strong> (<em>Numpy array of numbers</em>) – The rotated z coordinates.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">,</span> <span class="n">zr</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">rotate_3D_coordinates_around_axes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.scale_3D_coordinates">
<code class="descclassname">brainload.spatial.</code><code class="descname">scale_3D_coordinates</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>x_scale_factor</em>, <em>y_scale_factor=None</em>, <em>z_scale_factor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.scale_3D_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale coordinates by factors.</p>
<p>Scale the given coordinates by the given scale factor or factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Must have the same length as the <cite>y</cite> and <cite>z</cite> arrays.</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Must have the same length as the <cite>x</cite> and <cite>z</cite> arrays.</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Must have the same length as the <cite>x</cite> and <cite>y</cite> arrays.</li>
<li><strong>x_scale_factor</strong> (<em>number</em>) – A single number, representing the scaling factor along the x axis. If the other values are not given, this counts for all axes.</li>
<li><strong>y_scale_factor</strong> (<em>number | None</em>) – A single number, representing the scaling factor along the y axis. If this is <cite>None</cite>, the value given for <cite>x_scale_factor</cite> is used.</li>
<li><strong>z_scale_factor</strong> (<em>number | None</em>) – A single number, representing the scaling factor along the z axis. If this is <cite>None</cite>, the value given for <cite>x_scale_factor</cite> is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>x_scaled</strong> (<em>Numpy array of numbers</em>) – The scaled x coordinates.</li>
<li><strong>y_scaled</strong> (<em>Numpy array of numbers</em>) – The scaled y coordinates.</li>
<li><strong>z_scaled</strong> (<em>Numpy array of numbers</em>) – The scaled z coordinates.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">scale_3D_coordinates</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>     <span class="c1"># 15 21 27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># 18 24 30</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="brainload.spatial.translate_3D_coordinates_along_axes">
<code class="descclassname">brainload.spatial.</code><code class="descname">translate_3D_coordinates_along_axes</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>shift_x</em>, <em>shift_y</em>, <em>shift_z</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.spatial.translate_3D_coordinates_along_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate coordinates along one or more axes.</p>
<p>Translate or shift coordinates along one or more axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Numpy array of numbers</em>) – A 1D array representing x axis coordinates. Must have the same length as the <cite>y</cite> and <cite>z</cite> arrays.</li>
<li><strong>y</strong> (<em>Numpy array of numbers</em>) – A 1D array representing y axis coordinates. Must have the same length as the <cite>x</cite> and <cite>z</cite> arrays.</li>
<li><strong>z</strong> (<em>Numpy array of numbers</em>) – A 1D array, representing z axis coordinates. Must have the same length as the <cite>x</cite> and <cite>y</cite> arrays.</li>
<li><strong>shift_x</strong> (<em>number</em>) – A single number, representing the shift along the x axis.</li>
<li><strong>shift_y</strong> (<em>number</em>) – A single number, representing the shift along the y axis.</li>
<li><strong>shift_z</strong> (<em>number</em>) – A single number, representing the shift along the z axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>x_shifted</strong> (<em>Numpy array of numbers</em>) – The shifted x coordinates.</li>
<li><strong>y_shifted</strong> (<em>Numpy array of numbers</em>) – The shifted y coordinates.</li>
<li><strong>z_shifted</strong> (<em>Numpy array of numbers</em>) – The shifted z coordinates.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">brainload.spatial</span> <span class="k">as</span> <span class="nn">st</span><span class="p">;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">zt</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">translate_3D_coordinates_along_axes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">zt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>     <span class="c1"># 7 3 9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">xt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">yt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># 8 4 10</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-brainload.meshexport">
<span id="brainload-meshexport-module"></span><h2>brainload.meshexport module<a class="headerlink" href="#module-brainload.meshexport" title="Permalink to this headline">¶</a></h2>
<p>Functions for exporting meshes.</p>
<p>Functions for exporting brain meshes to formats used by common 3D modeling software.</p>
<dl class="function">
<dt id="brainload.meshexport.mesh_to_obj">
<code class="descclassname">brainload.meshexport.</code><code class="descname">mesh_to_obj</code><span class="sig-paren">(</span><em>vertex_coords</em>, <em>faces</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.meshexport.mesh_to_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an OBJ format string of a mesh.</p>
<p>Write an OBJ PLY format string of a mesh. The format is the Wavefront object format, see <cite>https://en.wikipedia.org/wiki/Wavefront_.obj_file</cite> for details. This exporter only writes the geometry, vertex colors are not a standard OBJ feature and are not included. Use mesh_to_ply to get vertex colors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vertex_coords</strong> (<em>numpy array of floats</em>) – A 2D array containing 3 coordinates for each vertex. Dimension is (n, 3) for n vertices.</li>
<li><strong>faces</strong> (<em>numpy array of integers</em>) – A 2D array containing 3 vertex indices per face. Dimension is (m, 3) for m faces.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The OBJ format string for the mesh.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.meshexport.mesh_to_ply">
<code class="descclassname">brainload.meshexport.</code><code class="descname">mesh_to_ply</code><span class="sig-paren">(</span><em>vertex_coords</em>, <em>faces</em>, <em>vertex_colors=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.meshexport.mesh_to_ply" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a PLY format string of a mesh.</p>
<p>Write a PLY format string of a mesh. See <a class="reference external" href="http://paulbourke.net/dataformats/ply/">http://paulbourke.net/dataformats/ply/</a> for details on the format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vertex_coords</strong> (<em>numpy array of floats</em>) – A 2D array containing 3 coordinates for each vertex. Dimension is (n, 3) for n vertices.</li>
<li><strong>faces</strong> (<em>numpy array of integers</em>) – A 2D array containing 3 vertex indices per face. Dimension is (m, 3) for m faces.</li>
<li><strong>vertex_colors</strong> (<em>numpy array</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – A 2D array with shape (n, 4) assigning a color to each vertex (for the n vertices in vertex_coords). The 4 values in each column define the 4 channels of an RGBA color. Channel values should be given as integers in range 0..255. If omitted, no vertex colors will be included in the PLY format string.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The PLY format string for the mesh.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.meshexport.scalars_to_colors_clist">
<code class="descclassname">brainload.meshexport.</code><code class="descname">scalars_to_colors_clist</code><span class="sig-paren">(</span><em>scalars</em>, <em>color_list</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.meshexport.scalars_to_colors_clist" title="Permalink to this definition">¶</a></dt>
<dd><p>Given scalar values and a color list, assign a color to each scalar value.</p>
<p>Given scalar values and a color list, assign a color to each scalar value. This is useful for exporting vertex colored brain meshes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>scalars</strong> (<em>scalar numpy array of shape</em><em> (</em><em>i</em><em>, </em><em>)</em><em></em>) – 1D array of i numerical scalar values, usually floats.</li>
<li><strong>cmap</strong> (<em>numpy array of shape</em><em> (</em><em>n</em><em>, </em><em>m</em><em>)</em>) – Array containing n colors, each of which is defined by m values (e.g., m=3 for RGB colors, m=4 for RGBA colors, but this function does not care for the meaning in any way).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An array that assigns one color to each value from the scalars parameter (use the index).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy int array of shape (i, m)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="brainload.meshexport.scalars_to_colors_matplotlib">
<code class="descclassname">brainload.meshexport.</code><code class="descname">scalars_to_colors_matplotlib</code><span class="sig-paren">(</span><em>data</em>, <em>matplotlib_cmap_name</em>, <em>data_normalization='linear'</em>, <em>custom_cmap=None</em><span class="sig-paren">)</span><a class="headerlink" href="#brainload.meshexport.scalars_to_colors_matplotlib" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign colors to scalars using a colormap from matplotlib.</p>
<p>Assign colors to scalars using functions and a colormap from matplotlib. This requires matplotlib to be installed, which is NOT a hard dependency of brainload. If you want to use this function, you need to install matplotlib.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>1D numpy array of numerical data</em><em>, </em><em>length n.</em>) – The scalars data, each data point will be assigned a color.</li>
<li><strong>matplotlib_cmap_name</strong> (<em>string</em>) – A valid name of a matplotlib colormap. Example: ‘Spectral’. Note that it is important to chose the color map based on the data and your application. For sequential data, try ‘viridis’ or ‘plasma’. For diverging data, try ‘Spectral’ or ‘coolwarm’. For qualitative color maps, try ‘tab10’ or ‘tab20’. See <a class="reference external" href="https://matplotlib.org/users/colormaps.html">https://matplotlib.org/users/colormaps.html</a> for details. If the parameter custom_cmap is given, this can be a freeform name for your that colormap.</li>
<li><strong>data_normalization</strong> (<em>string</em><em>, </em><em>one of</em><em> (</em><em>'linear'</em><em>, </em><em>'log'</em><em>)</em><em>, </em><em>optional</em>) – How the data should be normalized to match the range of the color map. Defaults to ‘linear’.</li>
<li><strong>custom_cmap</strong> (<em>matplotlib colormap instance</em><em>, </em><em>optional</em>) – A custom matplotlib colormap, e.g., one created using LinearSegmentedColormap.from_list() or other matplotlib functions. Optional. If given, takes precedence over matplotlib_cmap_name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An array that assigns one RGBA color to each value from the scalars parameter (use the index). A color is given as 4 floats (RGBA), each in range 0.0 to 1.0.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy float array of shape (n, 4)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="workflows.html" class="btn btn-neutral float-right" title="Brainload Example Workflows" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to brainload’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>