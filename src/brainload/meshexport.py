"""
Functions for exporting meshes.

Functions for exporting brain meshes to formats used by common 3D modeling software.
"""

import os
import sys
import numpy as np

def mesh_to_ply(vertex_coords, faces, vertex_colors=None):
    """
    Write a PLY format string of a mesh.

    Write a PLY format string of a mesh. See http://paulbourke.net/dataformats/ply/ for details on the format.
    """
    use_vertex_colors = vertex_colors is not None
    num_vertices = vertex_coords.shape[0]
    num_faces = faces.shape[0]
    hdr = _ply_header(num_vertices, num_faces, use_vertex_colors=use_vertex_colors)
    verts_rep = _ply_verts(vertex_coords, vertex_colors=vertex_colors)
    faces_rep = _ply_faces(faces)
    return ''.join([hdr, verts_rep, faces_rep])


def _ply_header(num_vertices, num_faces, use_vertex_colors=False):
    """
    Return a string representing the PLY format header for the given data properties.
    """
    hdr_top = """ply
format ascii 1.0
comment Generated by Brainload
"""

    hdr_verts = """element vertex %d
property float x
property float y
property float z
""" % num_vertices

    hdr_vertex_colors = """property uchar red
property uchar green
property uchar blue
property uchar alpha
"""

    hdr_face = "element face %d\nproperty list uchar int vertex_indices\n" % num_faces
    hdr_end = "end_header\n"

    if use_vertex_colors:
        hdr_elements = [hdr_top, hdr_verts, hdr_vertex_colors, hdr_face, hdr_end]
    else:
        hdr_elements = [hdr_top, hdr_verts, hdr_face, hdr_end]
    return ''.join(hdr_elements)


def _ply_verts(vertex_coords, vertex_colors=None):
    """
    Return a string representing the vertices in PLY format. Vertex colors are optional.
    """
    if vertex_coords.shape[0] == 0:
        return ''
    vert_reps = ["%f %f %f" % (v[0], v[1], v[2]) for v in vertex_coords]                      # x, y, z coords
    if vertex_colors is not None:
        col_reps = [" %d %d %d %d" % (c[0], c[1], c[2], c[3]) for c in vertex_colors]      # RGBA values of color
        vert_col_reps = [i+j for i,j in zip(vert_reps, col_reps)]
        return '\n'.join(vert_col_reps) + '\n'
    else:
        return '\n'.join(vert_reps) + '\n'


def _ply_faces(faces):
    """
    Return a string representing the faces in PLY format.
    """
    if faces.shape[0] == 0:
        return ''
    face_reps = ["3 %d %d %d" % (f[0], f[1], f[2]) for f in faces]                    # the 3 vertex indices defining the face
    return '\n'.join(face_reps) + '\n'


def _cmap():
    """
    Return a colormap.
    """
    import matplotlib.colors
    return matplotlib.colors.LinearSegmentedColormap.from_list("", ["yellow", "orange", "red", "violet", "blue"])


def _normalize_to_range_zero_one(data):
    """
    Normalize the given data to the range [0, 1].

    Parameters
    ----------
    numpy array
        1D numpy array of numerical data, length n.

    Returns
    numpy array
        1D numpy array of floats in range [0, 1] with length n. The normalized data.
    """
    data=np.array(data)
    if np.unique(data).shape[0]==1:
        return np.ones(data.shape)
    else:
        return (data - np.min(data)) / np.ptp(data)


def scalars_to_colors(scalars, cmap):
    """
    Given scalar values and a color map, assign a color to each scalar value.

    Given scalar values and a color map, assign a color to each scalar value. This is useful for exporting vertex colored brain meshes.

    Parameters
    ----------
    scalars: scalar numpy array of shape (i, ).
        1D array of i scalar values.

    cmap: numpy int array of shape n, m
        Array containing n colors, each of which is defined by m values (e.g., m=3 for RGB colors, m=4 for RGBA colors)

    Returns
    -------
    numpy int array of shape (i, m)
        An array that assigns one color to each value from the scalars parameter (use the index).
    """
    num_colors = cmap.shape[0]
    num_color_channels = cmap.shape[1]      # 3 or 4, depending on whether an alpha channel is included
    scalars = np.array(scalars)
    norm_scalars = _normalize_to_range_zero_one(scalars)
    min_scalar = 0.0
    max_scalar = 1.0
    num_scalars = norm_scalars.shape[0]
    assigned_colors = np.zeros((num_scalars, num_color_channels))

    it = np.nditer(norm_scalars, flags=['f_index'])
    while not it.finished:
        scalar = it[0]
        if scalar < min_scalar:
            assigned_colors[it.index][:] = cmap[0][:]       # assign first color in color map
        elif scalar > max_scalar:
            assigned_colors[it.index][:] = cmap[-1][:]      # assign last color in color map
        else:
            cmap_index = int(np.floor(num_colors * ((scalar - min_scalar) / (max_scalar - min_scalar))))
            if cmap_index >= num_colors:
                cmap_index = num_colors - 1
            assigned_colors[it.index][:] = cmap[cmap_index][:]
        it.iternext()
    return assigned_colors
